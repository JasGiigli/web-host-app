<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>JavaScript Course Outline</title>
  <link rel="stylesheet" href="./js_tutorial.css" />
  <link rel="stylesheet" href="../../dist/output.css" />
</head>

<!----------------------------------------- BODy --------------------------------------->

<body>
  <!--------------------------------ROOT NAVIGATION BAR ---------------------------------->
  <div class="bg-slate-900 text-white flex justify-center">
    <ul class="flex space-x-4 items-center text-2xl">
      <li><a href="../index.html">Home</a></li>
      <li><a href="./html_tutorial.html">HTML</a></li>
      <li><a href="./css_tutorial.html">CSS</a></li>
    </ul>
  </div>
  <!-- ************************* Main Page SIDE BAR FOR TABLE OF CONTENT **************************** -->
  <!-- Container for all the elements -->
  <div class="container bg-white shadow-lg">
    <!-- Container start div -->

    <!-- sidebar  div start-->
    <div class="sidebar" id="sidebar">
      <!-- sidebar  div start-->
      <h2 class="font-bold text-2xl">JS Tutorial</h2>
      <ul id="courseList">
        <li>
          <a href="#overview" class="font-bold mb-3">Introduction to JavaScript</a>
          <ul>
            <li>
              <a href="#overview" class="block mb-2 text-DarkPurple hover:text-DarkYellow">Overview</a>
            </li>
            <li>
              <a href="#history" class="block mb-2 text-DarkPurple hover:text-DarkYellow">History of JavaScript</a>
            </li>
            <li>
              <a href="#why" class="block mb-2 text-DarkPurple hover:text-DarkYellow">
                Why Learn JavaScript?</a>
            </li>
            <li>
              <a href="#current" class="block mb-2 text-DarkPurple hover:text-DarkYellow">
                Current State of JavaScript</a>
            </li>
            <li>
              <a href="#Career" class="block mb-2 text-DarkPurple hover:text-DarkYellow">
                Career of JavaScript</a>
            </li>
            <li>
              <a href="./jsExamples.html" class="bg-gray-300">What JavaScript Can Do!</a>
            </li>
            <!-- Add other links -->
          </ul>
        </li>

        <li>
          <a href="#lexicalStructure" class="font-bold mb-3 mt-3">
            JS Lexical Structure</a>
          <ul>
            <li>
              <a href="#text" class="block mb-2 text-DarkPurple hover:text-DarkYellow">JS Text</a>
            </li>
            <li>
              <a href="#comment" class="block mb-2 text-DarkPurple hover:text-DarkYellow">JS comments</a>
            </li>
            <li>
              <a href="#literal" class="block mb-2 text-DarkPurple hover:text-DarkYellow">JS Literals</a>
            </li>
            <li>
              <a href="#identifier" class="block mb-2 text-DarkPurple hover:text-DarkYellow">JS Identifiers</a>
            </li>
            <li>
              <a href="#reserved" class="block mb-2 text-DarkPurple hover:text-DarkYellow">JS Reserved Words</a>
            </li>
            <li>
              <a href="#unicode" class="block mb-2 text-DarkPurple hover:text-DarkYellow">JS Unicode</a>
              <ul>
                <li><a href="#escape">JS Unicode Escape Sequence</a></li>
              </ul>
            </li>
            <li>
              <a href="#optional" class="block mb-2 text-DarkPurple hover:text-DarkYellow">JS Optional Semicolon</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="#types" class="font-bold mb-3 mt-3">JS Types</a>
          <ul>
            <li class="font-semibold">
              <a href="#primitive">1-Primitive Data Types</a>
            </li>
            <li><a href="#number">Number</a></li>
            <li><a href="#numericliteral">JS Numeric Literals</a></li>
            <li><a href="#string">JS String</a></li>
            <li>
              <a href="#escape_sequence">JS Escape Sequence in String</a>
            </li>
            <li><a href="#boolean">JS Boolean</a></li>
            <li><a href="#null">JS Null</a></li>
            <li><a href="#undefine">JS Undefine</a></li>
            <li><a href="#symbol">JS Symbol</a></li>
            <li><a href="#bigint">JS BigInt</a></li>
          </ul>
        </li>
        <li>
          <ul>
            <li class="font-semibold">
              <a href="#reference">2-Reference Data Types</a>
            </li>
            <li><a href="#object">JS Object</a></li>
            <li><a href="#array">JS Array</a></li>
            <li><a href="#function">JS Function</a></li>
            <li><a href="#date">JS Date</a></li>
            <li><a href="#regex">JS Regular Expression</a></li>
            <li><a href="#map">JS Map</a></li>
            <li><a href="#set">JS Set</a></li>
            <li><a href="#promise">JS Promise</a></li>
            <li><a href="#math">JS Math</a></li>
            <li><a href="#error">JS Error</a></li>
            <li><a href="#global">JS Global Object</a></li>
          </ul>
        </li>
        <li>
          <a href="#variable" class="font-bold mb-3 mt-3">JS Variables</a>
          <ul>
            <li><a href="#var">Var</a></li>
            <li><a href="#let">Let</a></li>
            <li><a href="#const">Const</a></li>
          </ul>
        </li>
        <li>
          <a href="#expression" class="font-bold mb-3 mt-3">JS Expressions</a>
          <ul>
            <li><a href="#primaryExpression">Primary Exp</a></li>
            <li>
              <a href="#functionDefinitionExpression">Function Definition Exp</a>
            </li>
            <li>
              <a href="#propertyAccessExpression">Property Access Exp</a>
            </li>
            <li><a href="#invocationExpression">Invocation Exp</a></li>
            <li>
              <a href="#objectCreationExpression">Object Creation Exp</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="#operator" class="font-bold mb-3 mt-3">JS Operator</a>
          <ul>
            <li><a href="#arithmeticExpression">JS Arithmetic</a></li>
            <li><a href="#arithmeticExpression">JS Bitwise Arithmetic</a></li>
            <li><a href="#relationalExpression">JS Relational</a></li>
            <li><a href="#logicalExpression">JS Logical</a></li>
            <li><a href="#assignmentExpression">JS Assignment</a></li>
            <li><a href="#evaluationExpression">JS Evaluation</a></li>
            <li>
              <a href="#miscellaneousExpression" class="font-semibold">JS Miscellaneous OP</a>
              <ul>
                <li><a href="#conditionalOperator">JS Conditional Op</a></li>
                <li>
                  <a href="#firstDefineOperator">JS First-Defined (??) Op</a>
                </li>
                <li><a href="#typeofOperator">JS typeof Op</a></li>
                <li><a href="#deleteOperator">JS delete Op</a></li>
                <li><a href="#deleteOperator">JS delete Op</a></li>
                <li><a href="#awaitOperator">JS await Op</a></li>
                <li><a href="#voidOperator">JS void Op</a></li>
                <li><a href="#commaOperator">JS comma Op (,)</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li>
          <a href="#statements" class="font-bold mb-3 mt-3">JS Statements</a>
          <ul>
            <li>
              <a href="#expressionStatements" class="font-semibold">JS Expression Statements</a>
            </li>
            <li>
              <a href="#compoundEmptyStatements" class="font-semibold">JS Compound and Empty Statements</a>
            </li>
            <li>
              <a href="#conditionals" class="font-semibold">JS Conditionals</a>
            </li>
            <li><a href="#if">if</a></li>
            <li><a href="#elseif">else/if</a></li>
            <li><a href="#switch">switch</a></li>
            <li><a href="#loops" class="font-semibold">JS Loops</a></li>
            <li><a href="#while">while</a></li>
            <li><a href="#dowhile">dowhile</a></li>
            <li><a href="#for">for</a></li>
            <li><a href="#forof">forof</a></li>
            <li><a href="#forofWithObjects">forofWithObjects</a></li>
            <li><a href="#forofWithStrings">forofWithStrings</a></li>
            <li><a href="#forofWithSetAndMaps">while</a></li>
            <li><a href="#forawait">forawait</a></li>
            <li><a href="#forin">forin</a></li>
            <li><a href="#jumps" class="font-semibold">JS Jumps</a></li>
            <li><a href="#labels">labels</a></li>
            <li><a href="#breaks">breaks</a></li>
            <li><a href="#continues">continues</a></li>
            <li><a href="#returns">returns</a></li>
            <li><a href="#yields">yields</a></li>
            <li><a href="#throws">throws</a></li>
            <li><a href="#trycatchfinally">trycatchfinally</a></li>
            <li>
              <a href="#miscellaneousStatements" class="font-semibold">JS Miscellaneous Statements</a>
            </li>
            <li><a href="#with">with</a></li>
            <li><a href="#debugger">debugger</a></li>
            <li><a href="#useStrict">useStrict</a></li>
            <li>
              <a href="#declarations" class="font-semibold">JS Declarations</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="./js_ObjectsAdvance.html" class="font-bold mb-3 mt-3">JS Objects Advance</a>
        </li>
        <li>
          <a href="./js_Array.html" class="font-bold mb-3 mt-3">JS array Advance</a>
        </li>
        <li>
          <a href="./js_Function.html" class="font-bold mb-3 mt-3">JS functions Advance</a>
        </li>
        <li>
          <a href="./js_classes" class="font-bold mb-3 mt-3">JS classes Advance</a>
        </li>
        <li>
          <a href="./js_Modules.html" class="font-bold mb-3 mt-3">JS modules Advance</a>
        </li>
        <li>
          <a href="#Operator" class="font-bold mb-3 mt-3">Regular Expressions Advance</a>
        </li>
        <li>
          <a href="#Operator" class="font-bold mb-3 mt-3">Sets Advance</a>
        </li>
        <li>
          <a href="#Operator" class="font-bold mb-3 mt-3">Maps Advance</a>
        </li>
        <li>
          <a href="#Operator" class="font-bold mb-3 mt-3">Error Class Advance</a>
        </li>
        <li>
          <a href="#Operator" class="font-bold mb-3 mt-3">Dates & Times Advance</a>
        </li>
        <li>
          <a href="#Operator" class="font-bold mb-3 mt-3">Promises Advance</a>
        </li>
        <li>
          <a href="#Operator" class="font-bold mb-3 mt-3">async and Await</a>
        </li>
        <li>
          <a href="#Operator" class="font-bold mb-3 mt-3">Asynchronous Iterations</a>
        </li>
        <li>
          <a href="#Operator" class="font-bold mb-3 mt-3">JSON Object Advance</a>
        </li>
        <li>
          <a href="#Operator" class="font-bold mb-3 mt-3">API's</a>
        </li>
        <li>
          <a href="#Operator" class="font-bold mb-3 mt-3">JS Iteratorsr</a>
        </li>
        <li>
          <a href="#Operator" class="font-bold mb-3 mt-3">JS Generators</a>
        </li>
        <li>
          <a href="#Operator" class="font-bold mb-3 mt-3">Asynchronous JavaScript</a>
        </li>
        <li>
          <a href="#Operator" class="font-bold mb-3 mt-3">Metaprogramming</a>
        </li>
        <li>
          <a href="#Operator" class="font-bold mb-3 mt-3">JS in Web Browers</a>
        </li>
        <li>
          <a href="#Operator" class="font-bold mb-3 mt-3">Events</a>
        </li>
        <li>
          <a href="#Operator" class="font-bold mb-3 mt-3">JavaScript in Server-Side</a>
        </li>

        <!-- Add more topics and sub-topics as needed -->
      </ul>
      <!-- Side bar div end -->
    </div>
    <!-- Side bar div end -->

    <!--************* main content div start*************************************** -->
    <div class="main-content p-6 bg-white rounded-lg shadow-2xl">
      <!--************* main content div start*************************************** -->
      <button class="hamburger-btn">☰</button>
      <!-- Introduction to JavaScript sub-heading Bookmark div start -->
      <div class="mx-auto px-4 py-8 max-w-3xl">
        <!-- Introduction to JavaScript sub-heading Bookmark div start -->

        <!-- ********************** Overview of JavaScript ************************************** -->
        <!-- ********************** Overview of JavaScript ************************************** -->
        <!-- ********************** Overview of JavaScript ************************************** -->
        <!-- ********************** Overview of JavaScript ************************************** -->
        <!-- ********************** Overview of JavaScript ************************************** -->

        <div>
          <h1 id="overview"
            class="text-4xl font-bold mb-6 text-center hover:text-white hover:bg-blue-500 rounded-md shadow-lg bg-gray-300 p-10 text-blue-600 hover:underline">
            JavaScript Overview
          </h1>
          <p class="mb-4">
            <span class="font-semibold">JavaScript</span> is a
            <strong>lightweight, interpreted, just-in-time compiled, versatile, and
              widely-used
            </strong>
            programming language primarily utilized for creating
            <span class="font-semibold text-2xl text-DarkPurple">dynamic and interactive</span>
            web pages.
          </p>
          <p class="mb-4">
            <span class="italic text-DarkYellow text-2xl font-bold">Lightweight</span>: JavaScript's "lightweight"
            nature refers to its efficiency,
            speed in execution, low memory consumption, and smaller file
            sizes, enabling quick client-side handling of functionalities
            within web applications.
          </p>
          <p class="mb-4">
            <span class="italic text-DarkYellow text-2xl font-bold">Interpreted</span>: JavaScript being interpreted
            means that the code is executed
            line by line at runtime, without a separate compilation step,
            allowing for immediate execution within a web browser.
          </p>
          <p class="mb-4">
            <span class="italic text-DarkYellow text-2xl font-bold">Just-in-time compiled</span>: JavaScript being
            "just-in-time compiled" means that the code is
            not precompiled but compiled at runtime, optimizing performance by
            converting code into machine code as it's executed in the browser.
          </p>
          <p class="mb-4">
            <span class="italic text-DarkYellow text-2xl font-bold">Versatile</span>: It can be applied to a wide range
            of tasks, from front-end web
            development to back-end server programming, mobile app
            development, desktop applications, data visualization, and more.
            Its adaptability and broad usage make it a valuable programming
            language in the modern tech landscape.
          </p>
          <p class="mb-4">
            JavaScript is a
            <span class="italic">multi-paradigm language</span>, supporting
            event-driven, functional, and object-oriented programming.
          </p>
          <p class="mb-4">
            It was initially developed by
            <span class="text-DarkPurple font-bold">Netscape</span> as a
            client-side scripting language but has evolved to be used on both
            client and server sides through environments like Node.js,
            Deno.js, and Bun.js.
          </p>
          <p>
            <span class="italic text-DarkYellow text-2xl font-bold">Interactive</span>: Refers to user engagement and
            the ability to interact with
            elements on a web page, like click on the buttons etc.
            <span class="italic">Dynamic</span>: Implies that the content can
            change and update in response to various inputs or events, all
            without the need for a complete page refresh. For example, dynamic
            content loading of social media, real-time updates for likes and
            comments, and real-time notifications.
          </p>
          <div class="flex justify- rounded-md text-center">
            <img src="../../Assects/download.png" class="rounded-3xl h-60 w-72 m-5" alt="" />
          </div>
        </div>

        <!--***************************** History************************************************ -->
        <!--***************************** History************************************************ -->
        <!--***************************** History************************************************ -->
        <!--***************************** History************************************************ -->
        <!--***************************** History************************************************ -->

        <div class="mx-auto px-4 py-8 max-w-3xl">
          <h1 id="history" class="text-4xl font-bold mb-6">
            History of JavaScript
          </h1>
          <h1 class="text-3xl font-bold mb-6">
            A Comprehensive Journey Through JavaScript's History
          </h1>

          <section class="mb-8">
            <h2 class="text-xl font-semibold mb-4">
              Origins and Early Adoptions (1995-1998)
            </h2>
            <ul class="list-disc pl-6">
              <li class="mb-2">
                <strong>1995:</strong> Our story begins with Brendan Eich at
                Netscape Communications. In just 10 days, he invents a
                scripting language initially called "Mocha," quickly evolving
                to "LiveScript." Recognizing its potential, Netscape rebrands
                it as JavaScript in December 1995, hoping to leverage the
                popularity of Java.
              </li>
              <li class="mb-2">
                <strong>1996:</strong> Recognizing the language's promise,
                Netscape submits JavaScript to the European Computer
                Manufacturers Association (ECMA) for standardization.
              </li>
              <li class="mb-2">
                <strong>1997:</strong> The ECMA officially adopts JavaScript,
                standardizing it under the name ECMAScript. Internet Explorer
                4 still lags behind, only providing limited support for an
                earlier version of the language.
              </li>
            </ul>
          </section>

          <section class="mb-8">
            <h2 class="text-xl font-semibold mb-4">
              Standardization and Growth (1999-2008)
            </h2>
            <ul class="list-disc pl-6">
              <li class="mb-2">
                <strong>1998:</strong> Microsoft finally enters the fray,
                releasing Internet Explorer 5 with full-fledged ECMAScript
                support, igniting the "browser wars" and accelerating
                JavaScript's adoption.
              </li>
              <li class="mb-2">
                <strong>1999-2008:</strong> This period sees a flurry of
                ECMAScript upgrades, each adding new features and
                functionalities. ECMAScript 2 adds classes and prototypes,
                laying the foundation for object-oriented programming in
                JavaScript. ECMAScript 3 further refines the language,
                solidifying its position as a web development essential.
              </li>
            </ul>
          </section>

          <section class="mb-8">
            <h2 class="text-xl font-semibold mb-4">
              Modernization and Expansion (2009-Present)
            </h2>
            <ul class="list-disc pl-6">
              <li class="mb-2">
                <strong>2009:</strong> ECMAScript 5 arrives, marking a
                significant leap forward. With features like strict mode,
                enhanced object functionality, and arrow functions, it makes
                JavaScript more powerful and expressive.
              </li>
              <li class="mb-2">
                <strong>2015:</strong> ECMAScript 6 (also known as ES6)
                revolutionizes the language. Classes, modules, arrow
                functions, and promises become mainstream, paving the way for
                cleaner, more concise code and larger-scale applications.
              </li>
              <li class="mb-2">
                <strong>2018-Present:</strong> The evolution continues with
                subsequent ECMAScript updates. Async/await for asynchronous
                programming, improved object handling, and ever-expanding APIs
                enrich the landscape for developers. Today, JavaScript thrives
                not only in web development but also in server-side
                applications, mobile apps, and even game development.
              </li>
            </ul>
          </section>

          <section class="mb-8">
            <h2 class="text-xl font-semibold mb-4">Beyond Browsers</h2>
            <p>
              It's crucial to acknowledge that JavaScript has transcended its
              web browser origins. The rise of Node.js in 2009 enabled
              JavaScript to run seamlessly on servers, opening doors for
              server-side scripting and complex server applications.
              Frameworks like React, Angular, and Vue.js leverage JavaScript's
              power to build dynamic and interactive single-page applications,
              further expanding its reach.
            </p>
            <p class="mt-4">
              JavaScript's journey is far from over. With continuous
              innovation and a vibrant community, it's poised to remain a
              dominant force in shaping the future of web development and
              beyond.
            </p>
          </section>
          <div class="flex justify- rounded-md text-center">
            <img src="../../Assects/history.png" alt="" class="rounded-2xl m-5 h-60 w-72" />
          </div>
        </div>
        <!-- ************************************** Why Learn JavaScript 8*************************** -->
        <!-- ************************************** Why Learn JavaScript 8*************************** -->
        <!-- ************************************** Why Learn JavaScript 8*************************** -->
        <!-- ************************************** Why Learn JavaScript 8*************************** -->
        <!-- ************************************** Why Learn JavaScript 8*************************** -->

        <div id="why" class="mx-auto px-4 py-8 max-w-3xl">
          <h1 class="text-3xl font-bold mb-6">Why Learn JavaScript?</h1>

          <section class="mb-8">
            <p class="mb-4">
              In today's digital world, JavaScript is an essential skill for
              anyone who wants to understand and interact with the web. It's
              the programming language that powers the dynamic and interactive
              elements we see on most websites, from animations and hover
              effects to forms and games. But why exactly should you learn
              JavaScript? Let's delve into the top reasons:
            </p>

            <ol class="list-decimal pl-6">
              <li class="mb-6">
                <h2 class="text-xl font-semibold mb-2">1. It's Everywhere</h2>
                <p class="mb-2">
                  JavaScript is practically ubiquitous on the web. According
                  to StatCounter, over 97% of websites use JavaScript in some
                  form. This means that learning JavaScript opens doors to a
                  vast and ever-growing landscape of opportunities. Whether
                  you want to build your own website, contribute to existing
                  projects, or simply understand how the web works behind the
                  scenes, JavaScript is the key.
                </p>
              </li>

              <li class="mb-6">
                <h2 class="text-xl font-semibold mb-2">2. It's Versatile</h2>
                <p class="mb-2">
                  JavaScript is not just for websites anymore. It has evolved
                  into a powerful and versatile language used for various
                  purposes, including:
                </p>
                <ul class="list-disc pl-6">
                  <li class="mb-2">
                    Mobile App Development: Frameworks like React Native and
                    Ionic allow you to build cross-platform mobile apps using
                    JavaScript, reaching a wider audience with a single
                    codebase.
                  </li>
                  <li class="mb-2">
                    Server-Side Development: Node.js, a popular runtime
                    environment, lets you run JavaScript code on servers,
                    enabling you to build back-end applications and APIs.
                  </li>
                  <li class="mb-2">
                    Desktop App Development: Frameworks like Electron allow
                    you to develop cross-platform desktop applications using
                    familiar web technologies like HTML, CSS, and JavaScript.
                  </li>
                  <li class="mb-2">
                    Game Development: Libraries like Phaser and PixiJS empower
                    you to create interactive and engaging games using
                    JavaScript.
                  </li>
                </ul>
              </li>

              <li class="mb-6">
                <h2 class="text-xl font-semibold mb-2">
                  3. It's Relatively Easy to Learn
                </h2>
                <p class="mb-2">
                  Compared to other programming languages, JavaScript has a
                  syntax that is considered beginner-friendly and easier to
                  grasp. With its abundance of online resources, tutorials,
                  and interactive platforms, learning JavaScript is more
                  accessible than ever before.
                </p>
              </li>

              <li class="mb-6">
                <h2 class="text-xl font-semibold mb-2">
                  4. It's In High Demand
                </h2>
                <p class="mb-2">
                  The demand for skilled JavaScript developers is constantly
                  growing. According to Indeed, JavaScript developer jobs are
                  among the most in-demand positions globally. Learning
                  JavaScript can open doors to exciting career opportunities
                  in various industries, from web development and software
                  engineering to data science and game development.
                </p>
              </li>

              <li class="mb-6">
                <h2 class="text-xl font-semibold mb-2">
                  5. It's Fun and Rewarding
                </h2>
                <p class="mb-2">
                  Creating something interactive and dynamic with JavaScript
                  can be incredibly rewarding. Seeing your code come to life
                  and bring your ideas to fruition is a truly satisfying
                  experience. Whether you're building a simple game or a
                  complex web application, the possibilities are endless with
                  JavaScript.
                </p>
              </li>
            </ol>

            <p class="mb-4">Start your JavaScript Journey Today!</p>

            <p>
              If you're looking for a future-proof skill with endless
              possibilities, learning JavaScript is a wise investment. With
              its versatility, ease of learning, and high demand, JavaScript
              can empower you to create engaging experiences, build innovative
              applications, and unlock exciting career opportunities. So, what
              are you waiting for? Start your JavaScript journey today and
              join the vibrant community of developers shaping the future of
              the web!
            </p>
          </section>
        </div>

        <!-- ********************** Current Status of JavaScript ***************************************** -->
        <!-- ********************** Current Status of JavaScript ***************************************** -->
        <!-- ********************** Current Status of JavaScript ***************************************** -->
        <!-- ********************** Current Status of JavaScript ***************************************** -->
        <!-- ********************** Current Status of JavaScript ***************************************** -->

        <div class="mx-auto px-4 py-8 max-w-3xl">
          <h1 id="current" class="text-3xl font-bold mb-6">
            Current State of JavaScript in 2023
          </h1>

          <section class="mb-8">
            <h2 class="text-2xl font-semibold mb-4">
              Key Trends and Advancements:
            </h2>

            <ul class="list-disc pl-6 mb-6">
              <li class="mb-2">
                Continuous Evolution: JavaScript remains one of the most
                actively developed programming languages, with regular updates
                to the ECMAScript specification (ES2022 being the latest).
              </li>
              <li class="mb-2">
                Embracing Modern Features: Developers are increasingly using
                features introduced in recent ES versions, such as:
              </li>
              <ul class="list-disc pl-6">
                <li class="mb-1">Arrow functions</li>
                <li class="mb-1">Classes</li>
                <li class="mb-1">Modules</li>
                <li class="mb-1">Async/await</li>
                <li class="mb-1">Promises</li>
                <li class="mb-1">Destructuring</li>
              </ul>
              <li class="mb-2">
                Framework Dominance: React, Vue.js, and Angular continue to be
                the most popular front-end frameworks, but newer contenders
                like Svelte and SolidJS are gaining traction.
              </li>
              <li class="mb-2">
                Node.js Expansion: Server-side JavaScript with Node.js is
                thriving, powering back-end applications, APIs, and serverless
                functions.
              </li>
              <li class="mb-2">
                TypeScript Adoption: TypeScript, a superset of JavaScript with
                optional static typing, is gaining popularity for its improved
                code safety and maintainability.
              </li>
              <li class="mb-2">
                JavaScript Everywhere: JavaScript's reach extends beyond web
                development into:
              </li>
              <ul class="list-disc pl-6">
                <li class="mb-1">
                  Mobile app development (React Native, Ionic)
                </li>
                <li class="mb-1">Desktop app development (Electron)</li>
                <li class="mb-1">Game development (Phaser, PixiJS)</li>
                <li class="mb-1">Machine learning (TensorFlow.js)</li>
              </ul>
            </ul>

            <h2 class="text-2xl font-semibold mb-4">Ecosystem Highlights:</h2>

            <ul class="list-disc pl-6 mb-6">
              <li class="mb-2">
                Package Managers: npm and Yarn remain essential for managing
                JavaScript dependencies.
              </li>
              <li class="mb-2">
                Build Tools: Webpack and Parcel are popular choices for
                bundling and optimizing JavaScript code.
              </li>
              <li class="mb-2">
                Testing Frameworks: Jest and Mocha are widely used for testing
                JavaScript applications.
              </li>
            </ul>

            <h2 class="text-2xl font-semibold mb-4">
              Challenges and Opportunities:
            </h2>

            <ul class="list-disc pl-6 mb-6">
              <li class="mb-2">
                JavaScript Fatigue: The vastness of the JavaScript ecosystem
                can be overwhelming for developers, leading to decision
                fatigue.
              </li>
              <li class="mb-2">
                Performance Optimization: Ensuring smooth user experiences
                across devices and browsers requires careful optimization
                techniques.
              </li>
              <li class="mb-2">
                Security: Protecting against vulnerabilities like XSS and CSRF
                remains crucial in JavaScript development.
              </li>
              <li class="mb-2">
                Accessibility: Building inclusive web experiences that cater
                to users with disabilities is a growing priority.
              </li>
              <li class="mb-2">
                WebAssembly: This technology allows running code written in
                languages like C and C++ in web browsers, opening new
                possibilities for JavaScript.
              </li>
            </ul>

            <h2 class="text-2xl font-semibold mb-4">Future Outlook:</h2>

            <p class="mb-4">
              Continuous Innovation: Expect ongoing advancements in JavaScript
              features, frameworks, and tools. Specialization within the
              ecosystem may become more prominent. Integration with emerging
              technologies like WebAssembly, virtual reality, and artificial
              intelligence is likely.
            </p>

            <p class="mb-4">
              Overall, JavaScript is in a vibrant and dynamic state, offering
              a powerful and versatile foundation for web development and
              beyond. Embracing its modern features, frameworks, and best
              practices is crucial for developers to stay relevant and create
              innovative experiences in the years to come.
            </p>
          </section>
        </div>

        <!--***************************** Career of JavaScript ************************************** -->
        <!--****************************** Career of JavaScript ************************************** -->
        <!--****************************** Career of JavaScript ************************************** -->
        <!--******************************* Career of JavaScript ************************************** -->
        <!--********************************** Career of JavaScript ********************************** -->

        <div class="mx-auto px-4 py-8 max-w-3xl">
          <h1 id="Career" class="text-3xl font-bold mb-6">
            Dive into the Exciting World of JavaScript Careers
          </h1>

          <section class="mb-8">
            <p class="mb-4">
              Learning JavaScript opens doors to a plethora of rewarding
              career paths in today's digital world. Its versatility and
              ubiquity make it a highly sought-after skill, offering exciting
              opportunities across various industries. Let's explore some of
              the potential career paths for JavaScript developers:
            </p>

            <ol class="list-decimal pl-6 mb-8">
              <li class="mb-4">
                <h2 class="text-xl font-semibold mb-2">Web Development:</h2>
                <ul class="list-disc pl-6">
                  <li class="mb-1">
                    <strong>Front-End Developer:</strong> Build the
                    interactive and user-facing aspects of websites and web
                    applications using HTML, CSS, and JavaScript frameworks
                    like React, Vue.js, or Angular.
                  </li>
                  <li class="mb-1">
                    <strong>Full-Stack Developer:</strong> Master both
                    front-end and back-end development, handling everything
                    from user interfaces to server-side logic using Node.js
                    and JavaScript frameworks.
                  </li>
                  <li class="mb-1">
                    <strong>UX/UI Designer:</strong> Leverage JavaScript to
                    create interactive prototypes and mockups, providing a
                    realistic user experience to design teams.
                  </li>
                </ul>
              </li>

              <li class="mb-4">
                <h2 class="text-xl font-semibold mb-2">
                  Mobile App Development:
                </h2>
                <ul class="list-disc pl-6">
                  <li class="mb-1">
                    <strong>Mobile App Developer:</strong> Build
                    cross-platform mobile apps using frameworks like React
                    Native or Ionic, reaching a broader audience with a single
                    codebase.
                  </li>
                  <li class="mb-1">
                    <strong>Game Developer:</strong> Develop interactive and
                    engaging games using JavaScript libraries like Phaser and
                    PixiJS, bringing your creative vision to life.
                  </li>
                </ul>
              </li>

              <li class="mb-4">
                <h2 class="text-xl font-semibold mb-2">
                  Server-Side Development:
                </h2>
                <ul class="list-disc pl-6">
                  <li class="mb-1">
                    <strong>Back-End Developer:</strong> Use Node.js to build
                    server-side applications, APIs, and microservices,
                    powering the logic behind websites and web applications.
                  </li>
                  <li class="mb-1">
                    <strong>DevOps Engineer:</strong> Utilize JavaScript
                    automation tools to manage infrastructure, deploy
                    applications, and automate processes for efficient
                    software development.
                  </li>
                </ul>
              </li>

              <li class="mb-4">
                <h2 class="text-xl font-semibold mb-2">
                  Other Exciting Opportunities:
                </h2>
                <ul class="list-disc pl-6">
                  <li class="mb-1">
                    <strong>Data Analyst/Scientist:</strong> Integrate
                    JavaScript with data visualization libraries to analyze
                    data and create interactive dashboards.
                  </li>
                  <li class="mb-1">
                    <strong>AI/ML Engineer:</strong> Apply JavaScript
                    frameworks like TensorFlow.js to build and deploy machine
                    learning models.
                  </li>
                  <li class="mb-1">
                    <strong>Freelancer/Consultant:</strong> Offer your
                    JavaScript expertise to clients on a project-by-project
                    basis, gaining flexibility and variety in your work.
                  </li>
                </ul>
              </li>
            </ol>

            <!-- Additional content omitted for brevity -->

            <p class="mb-6">
              Whether you're a seasoned developer or just starting your
              journey, JavaScript offers a promising career path filled with
              opportunities to innovate, create, and build the future of the
              web and beyond. So, dive in, embrace the possibilities, and let
              your JavaScript skills take you to exciting new heights!
            </p>
          </section>
        </div>
        <!--Introduction to JavaScript Sub-Heading Bookmark div end -->
      </div>
      <!-- Introduction to JavaScript Sub-Heading Bookmark div end -->
      <div class="mx-auto px-4 py-8 max-w-3xl">
        <!--********************** Lexical Structure of JavaScript *********************************** -->
        <!--************************ Lexical Structure of JavaScript ****************************** -->
        <!--****************************** Lexical Structure of JavaScript *************************** -->
        <!--************************** Lexical Structure of JavaScript ******************************* -->
        <!--******************************Lexical Structure of JavaScript ************************* -->
        <div id="lexicalStructure">
          <h2
            class="font-bold bg-gray-300 text-blue-600 shadow-lg p-2 hover:bg-blue-500 hover:text-white text- rounded-md text-center text-3xl hover:underline mb-8">
            JS Lexical Structure
          </h2>
          <p class="mb-4">
            Lexical structure in programming is like a builder's rulebook. It
            tells us how to write code correctly, just as builders follow
            rules to make strong buildings
          </p>
        </div>
        <!--******************************** Text in JS ************************************ -->
        <secton>
          <h1 id="text"
            class="font-bold bg-gray-300 text-blue-600 shadow-lg p-2 hover:bg-blue-500 hover:text-white text- rounded-md text-center text-3xl hover:underline mb-8">
            JS Text
          </h1>

          <p>
            JavaScript is a case-sensitive language. This means that language
            keywords, variables, function names, and other identifiers must
            always be typed with a consistent capitalization of letters
          </p>
        </secton>

        <!--******************************************* Comments in JS ************************-->

        <section class="mx-auto p-4">
          <h2 id="comment"
            class="font-bold bg-gray-300 text-blue-600 shadow-lg p-2 hover:bg-blue-500 hover:text-white text- rounded-md text-center text-3xl hover:underline mb-8">
            JS Comments
          </h2>
          <p>
            Comments in JavaScript are text not executed by the program;
            instead, they serve as notes for developers to explain code or
            temporarily disable parts of it.
          </p>
          <h3 class="font-semibold mt-4 mb-2">Types of Comments:</h3>
          <ol class="list-decimal pl-6">
            <li class="mb-2">
              <strong>Single-line Comments:</strong><br />
              Begin with <code>//</code>. Anything following
              <code>//</code> on that line is ignored by the JavaScript
              engine.
              <pre class="inline bg-gray-100 p-1 rounded">
 // This is a single-line comment explaining the code below
          let x = 5; // This assigns the value 5 to the variable x</pre>
            </li>
            <li class="mb-2">
              <strong>Multi-line Comments:</strong><br />
              Enclosed between <code>/*</code> and <code>*/</code>. These can
              span multiple lines.
              <pre class="inline bg-gray-100 p-1 rounded">
 /* 
          This is a multi-line comment.
          It can cover several lines without the need for '//' at the start of each line.
          */
          let y = 10; // This line of code is executed</pre>
            </li>
          </ol>
          <h3 class="font-semibold mt-4 mb-2 text-xl">
            Purposes of Comments:
          </h3>
          <ul class="list-disc pl-6">
            <li class="mb-2">
              <em>Explanation</em>
            </li>
            <li class="mb-2">
              <em>Documentation</em>
            </li>
            <li>
              <em>Debugging</em>
            </li>
          </ul>
        </section>

        <!--********************** Litarl in JS****************************** -->
        <h2 id="literal"
          class="font-bold bg-gray-300 text-blue-700 shadow-lg p-2 hover:bg-blue-500 hover:text-white text- rounded-md text-center text-3xl hover:underline mb-8 mt-32">
          JS Literals
        </h2>
        <section class="mx-auto p-4">
          <p>
            In JavaScript, literals are the raw data values you insert into
            your code. It appears directly in a program
          </p>
          <pre>
              <code>
                  12, // The number twelve
    1.2, // The number one point two
    "hello world", // A string of text
    'Hi', // Another string
    true, // A Boolean value
    false, // The other Boolean value
    null // Absence of an object
              </code>
            </pre>
        </section>

        <!--********************** Identifiers in JS****************************** -->
        <h1 id="identifier"
          class="font-bold bg-gray-300 text-blue-700 shadow-lg p-2 hover:bg-blue-500 hover:text-white text- rounded-md text-center text-3xl hover:underline mb-8 mt-32">
          Identifiers in JavaScript
        </h1>
        <section class="">
          <p class="mb-2">
            An identifier in JavaScript is like a name you give to different
            elements, such as constants, variables, functions, or classes.
          </p>
          <p class="mb-2">
            It's similar to a label that helps JavaScript understand what
            you're referring to.
          </p>
          <p class="mb-2">To create a valid identifier in JavaScript:</p>
          <ul class="list-disc ml-6 mb-4">
            <li>
              It must start with a letter, underscore (_), or dollar sign ($).
            </li>
            <li>
              After that, you can use letters, numbers, underscores, or dollar
              signs.
            </li>
            <li>
              The first character can't be a number to avoid confusion between
              identifiers and actual numbers.
            </li>
          </ul>
          <p class="mb-2">Here are examples of valid identifiers:</p>
          <ul class="list-disc ml-6 mb-4">
            <li>i</li>
            <li>my_variable_name</li>
            <li>v13</li>
            <li>_dummy</li>
            <li>$str</li>
          </ul>
        </section>

        <!--********************** Reserved Words in JS****************************** -->
        <h2 id="reserved"
          class="font-bold bg-gray-300 text-blue-700 shadow-lg p-2 hover:bg-blue-500 hover:text-white text- rounded-md text-center text-3xl hover:underline mb-8 mt-32">
          Reserved Words in JavaScript
        </h2>
        <section class="p-4 bg-gray-100 rounded-md shadow-md">
          <p class="mb-2">
            In JavaScript, some words are reserved for the language itself.
          </p>
          <p class="mb-2">
            Many of these words, like `if`, `while`, and `for`, are keywords
            that can't be used as names for constants, variables, functions,
            or classes.
          </p>
          <p class="mb-2 text-red-600">
            Although they can be used as property names within an object.
          </p>
          <p class="mb-2 text-blue-600">
            Some words, such as `from`, `of`, `get`, and `set`, have limited
            contexts and are legal as identifiers.
          </p>
          <p class="mb-2 text-green-500">
            Others like `let` have complex rules - they can be used as
            identifiers in specific situations but not always.
          </p>

          <p class="mb-2">
            JavaScript also reserves or restricts some keywords that might be
            used in future versions:
          </p>
          <ul class="list-disc ml-6 mb-4">
            <li>enum</li>
            <li>implements</li>
            <li>interface</li>
            <li>package</li>
            <li>private</li>
            <li>protected</li>
            <li>public</li>
          </ul>
        </section>
        <!-- ******************************Unicode in JS **************************************************-->
        <h2 id="unicode"
          class="font-bold bg-gray-300 text-blue-700 shadow-lg p-2 hover:bg-blue-500 hover:text-white text- rounded-md text-center text-3xl hover:underline mb-8 mt-32">
          Unicode in JavaScript
        </h2>
        <section class="p-4 bg-gray-100 rounded-md shadow-md">
          <p class="mb-2">
            JavaScript uses the Unicode character set for writing programs.
          </p>
          <p class="mb-2">
            In strings and comments, you can use any Unicode characters.
          </p>
          <p class="mb-2">
            For simplicity and consistency, it's common to stick to ASCII
            letters and digits in identifiers.
          </p>

          <p class="mb-2">
            This flexibility means programmers can employ mathematical symbols
            or words from non-English languages as constants or variables:
          </p>
          <div class="bg-gray-200 p-3 rounded-md border border-gray-300 mb-4">
            <code class="text-gray-700">const π = 3.14;<br />const sí = true;</code>
          </div>
        </section>
        <!--************************** Unicode Escape Sequence***************** -->
        <h2 id="escape"
          class="font-bold bg-gray-300 text-blue-700 shadow-lg p-2 hover:bg-blue-500 hover:text-white text- rounded-md text-center text-3xl hover:underline mb-8 mt-32">
          Unicode Escape Sequences in JavaScript
        </h2>
        <section class="p-4 bg-gray-100 rounded-md shadow-md">
          <p class="mb-2">
            Certain computer systems can't handle the entire range of Unicode
            characters. To assist programmers and older technology, JavaScript
            offers escape sequences.
          </p>
          <p class="mb-2">
            These sequences, beginning with `\u`, allow us to represent
            Unicode characters using only ASCII characters.
          </p>
          <p class="mb-2">
            Unicode escapes are either `\u` followed by exactly four
            hexadecimal digits (using uppercase or lowercase A-F) or enclosed
            within curly braces, ranging from one to six hexadecimal digits.
          </p>

          <div class="bg-gray-200 p-3 rounded-md border border-gray-300 mb-4">
            <code class="text-gray-700">let café = 1; // Define a variable using a Unicode character<br />caf\u00e9
                // => 1; access using an escape sequence<br />caf\u{E9} // => 1;
                another form of the same escape</code>
          </div>
          <p class="mb-2 text-green-500">
            Earlier JavaScript versions supported the four-digit escape
            sequence. ES6 introduced the curly brace version to handle Unicode
            codepoints needing more than 16 bits, like emojis.
          </p>
          <p class="mb-2">
            For example,
            <code class="text-gray-700">console.log("\u{1F600}");</code> would
            print a smiley face emoji.
          </p>
        </section>

        <!--************************** Optional Semicolone***************** -->
        <section class="p-4 bg-gray-100 rounded-md shadow-md">
          <h2 id="optional"
            class="font-bold bg-gray-300 text-blue-700 shadow-lg p-2 hover:bg-blue-500 hover:text-white text- rounded-md text-center text-3xl hover:underline mb-8 mt-32">
            Optional Semicolons in JavaScript
          </h2>
          <p class="mb-2">
            Semicolons in JavaScript separate statements and clarify code
            meaning.
          </p>
          <p class="mb-2">
            In most cases, you can omit semicolons between separate-line
            statements or before a closing curly brace `}`.
          </p>
          <p class="mb-2">
            However, JavaScript won't insert a semicolon after every line
            break - it usually does so when the next token cannot continue the
            current statement.
          </p>
          <p class="mb-2">Exceptions exist:</p>
          <ul class="list-disc ml-6 mb-4">
            <li>
              Specific keywords like `return`, `throw`, `yield`, `break`, and
              `continue` followed by an identifier or expression will force a
              semicolon after a line break.
            </li>
            <li>
              Operators like `++` and `--` used as postfix operators must be
              on the same line as the expression they apply to.
            </li>
            <li>
              Arrow functions must have the `=>` arrow on the same line as the
              parameter list.
            </li>
          </ul>
          <p class="mb-2 text-red-600">
            Sometimes, code without semicolons might lead to unexpected
            interpretations, like functions called across separate lines or
            unintended function invocations.
          </p>
        </section>

        <!--------------------------------------------------------------------------------- Types in JS -->
        <!--------------------------------------------------------------------------------- Types in JS -->
        <!--------------------------------------------------------------------------------- Types in JS -->
        <!--------------------------------------------------------------------------------- Types in JS -->
        <!--------------------------------------------------------------------------------- Types in JS -->
        <div class="types">
          <section class="p-8 bg-gray-100">
            <h1 id="types"
              class="font-bold bg-gray-300 text-blue-700 shadow-lg p-2 hover:bg-blue-500 hover:text-white text- rounded-md text-center text-3xl hover:underline mb-8 mt-32">
              Types in JavaScript
            </h1>
            <p class="text-lg">
              Computer programs work by manipulating values, such as the
              number 3.14 or the text “Hello World.” The kinds of values that
              can be represented and manipulated in a programming language are
              known as types, and one of the most fundamental characteristics
              of a programming language is the set of types it supports. These
              types define the nature of values and how they are stored and
              manipulated in a JavaScript program.
            </p>
            <h2 class="mt-4 text-xl font-bold text-red-600">
              Different Types in JS
            </h2>
            <p class="mt-2">
              JavaScript types can be divided into two categories: primitive
              types and object types.
            </p>

            <ul class="list-disc ml-8">
              <li>
                <div class="p-4 bg-gray-100">
                  <h2 class="text-xl font-bold">Primitive Types:</h2>
                  <p>
                    Primitive types in JavaScript are the simplest data types
                    representing single, fundamental values.
                  </p>
                  <ul class="list-disc ml-6">
                    <li>
                      <strong>Immutable:</strong> Their values cannot be
                      changed directly.
                    </li>
                    <li>
                      <strong>Stored directly in memory:</strong> They don't
                      have properties or methods.
                    </li>
                  </ul>
                </div>
                <p>
                  Primitives are immutable: there is no way to change (or
                  “mutate”) a primitive value. This is obvious for numbers and
                  booleans—it doesn’t even make sense to change the value of a
                  number. It is not so obvious for strings, however. Since
                  strings are like arrays of characters, you might expect to
                  be able to alter the character at any specified index. In
                  fact, JavaScript does not allow this, and all string methods
                  that appear to return a modified string are, in fact,
                  returning a new string value
                </p>
                <em>Primitives are also compared by value: two values are the
                  same only if they have the same value</em>
                <strong>Primitive Types:</strong>
                <ul class="list-disc ml-8">
                  <li>Numbers (e.g., 3.14)</li>
                  <li>Strings (e.g., "Hello World")</li>
                  <li>Booleans (e.g., true or false)</li>
                  <li>Null (represents the absence of a value)</li>
                  <li>
                    Undefined (denotes a variable that has been declared but
                    hasn't been assigned a value)
                  </li>
                  <li>
                    Symbols (unique and immutable values, introduced in ES6)
                  </li>
                  <li>
                    BigInts (for working with large integers, introduced in
                    ES11)
                  </li>
                </ul>
              </li>
              <li>
                <div class="p-4 bg-gray-100">
                  <h2 class="text-xl font-bold">Object Types:</h2>
                  <p>
                    Object types in JavaScript represent more complex data
                    structures organized as key-value pairs, forming
                    collections of values.
                  </p>
                  <ul class="list-disc ml-6">
                    <li>
                      <strong>Mutable:</strong> Properties and values within
                      objects can be changed.
                    </li>
                    <li>
                      <strong>Stored as references in memory:</strong> The
                      reference points to the actual object data.
                    </li>
                    <li>
                      <strong>Have properties and methods:</strong> These
                      enable interaction with the data stored within the
                      object.
                    </li>
                  </ul>
                </div>
                <p>
                  Objects are different than primitives. First, they are
                  mutable—their values can chang
                </p>
                <em>Objects are not compared by value: two distinct objects are
                  not equal even if they have the same properties and values.
                  And two distinct arrays are not equal even if they have the
                  same elements in the same order</em>
                <b>Two object values are the same if and only if they refer to
                  the same underlying object.
                </b>
                <strong>Object Types:</strong>
                <ul class="list-disc ml-8">
                  <li>Objects (e.g., { key: 'value' })</li>
                  <li>Arrays</li>
                  <li>Functions</li>
                  <li>Dates</li>
                  <li>Regular Expressions</li>
                  <li>Maps</li>
                  <li>Sets</li>
                  <li>WeakMaps</li>
                  <li>WeakSets</li>
                </ul>
              </li>
            </ul>
          </section>

          <!------------------------------------------ Number in Js---------------------------------------- -->
          <section>
            <h1 id="number"
              class="font-bold bg-gray-300 text-blue-700 shadow-lg p-2 hover:bg-blue-500 hover:text-white text- rounded-md text-center text-3xl hover:underline mb-8 mt-32">
              JS Number
            </h1>
            <div>
              <p>
                JavaScript's primary numeric type, Number, handles integers
                and approximates real numbers using a 64-bit floating-point
                format, following the IEEE 754 standard.
              </p>
              <p>
                It can represent a range from ±1.7976931348623157 × 10^308 to
                ±5 × 10^-324. The format precisely represents integers between
                −9,007,199,254,740,992 (−2^53) and 9,007,199,254,740,992
                (2^53), inclusive. However, if integers exceed this range,
                precision in the trailing digits may be lost.
              </p>
            </div>
          </section>
          <section>
            <h1 id="numericliteral"
              class="font-bold bg-gray-300 text-blue-700 shadow-lg p-2 hover:bg-blue-500 hover:text-white text- rounded-md text-center text-3xl hover:underline mb-8 mt-32">
              Js Numeric Literals
            </h1>
            <p>
              When a number appears directly in a JavaScript program, it’s
              called a numeric literal. JavaScript supports numeric literals
              in several formats.
            </p>
            <pre class="bg-gray-300 shadow-sm rounded-md p-2"><code>
                0
                1
                308
                −324
                5353</code></pre>
            <div class="p-4 bg-gray-100">
              <h2 class="text-xl font-bold">
                Types of Numeric Literals in JavaScript:
              </h2>
              <ol class="list-decimal ml-6">
                <li>
                  <strong>Integer Literals:</strong>
                  <ul class="list-disc ml-6">
                    <li>Represent whole numbers without decimal points.</li>
                    <li>
                      Decimal (base 10): Default, no prefix needed (e.g., 123,
                      -56, 0)
                    </li>
                    <li>
                      Octal (base 8): Prefixed with 0o or 0O (e.g., 0o73,
                      -0o54, 0o2047)
                    </li>
                    <li>
                      Hexadecimal (base 16): Prefixed with 0x or 0X (e.g.,
                      0xAF, -0xC5, 0x2005)
                    </li>
                    <li>
                      Binary (base 2): Prefixed with 0b or 0B (e.g., 0b1101,
                      -0b1010, 0b1000001)
                    </li>
                  </ul>
                </li>
                <li>
                  <strong>Floating-Point Literals (Decimal Numbers):</strong>
                  <ul class="list-disc ml-6">
                    <li>
                      Represent numbers with decimal points or exponents.
                    </li>
                    <li>
                      Exponents denoted by e or E (e.g., 3.14159, -2.5e2,
                      1.234e-5)
                    </li>
                  </ul>
                </li>
                <li>
                  <strong>BigInt Literals:</strong>
                  <ul class="list-disc ml-6">
                    <li>
                      Represent arbitrarily large integers, beyond the range
                      of regular numbers.
                    </li>
                    <li>
                      Suffixed with n (e.g., 9007199254740991n,
                      -100000000000000000n)
                    </li>
                  </ul>
                </li>
              </ol>
            </div>
          </section>
          <section>
            <h1 id="string"
              class="font-bold bg-gray-300 text-blue-700 shadow-lg p-2 hover:bg-blue-500 hover:text-white text- rounded-md text-center text-3xl hover:underline mb-8 mt-32">
              JS String
            </h1>
            <div class="p-4 bg-gray-100">
              <h2 class="text-xl font-bold">
                JavaScript Strings in a Nutshell:
              </h2>
              <ul class="list-disc ml-6">
                <li>
                  What they are:
                  <p>Strings store text in JavaScript.</p>
                </li>
                <li>
                  How they're built:
                  <p>
                    Strings are like ordered lists of characters. Each
                    character is usually a Unicode symbol.
                  </p>
                </li>
                <li>
                  Immutable:
                  <p>You can't change a string after you create it.</p>
                </li>
                <li>
                  Zero-based indexing:
                  <p>
                    The first character is at position 0, the second at 1, and
                    so on.
                  </p>
                </li>
                <li>
                  Length:
                  <p>
                    The number of characters (16-bit values) in the string.
                  </p>
                </li>
                <li>
                  Creating strings:
                  <p>
                    Use single quotes ('), double quotes ("), or backticks
                    (`).
                  </p>
                </li>
                <li>
                  ES6 backticks:
                  <p>
                    Allow expressions inside strings (e.g., `Hi, ${name}!`).
                  </p>
                </li>
                <li>
                  Multiline strings:
                  <ul class="list-disc ml-6">
                    <li>ES5: Break lines with a backslash (\).</li>
                    <li>ES6: Use backticks for automatic line breaks.</li>
                  </ul>
                </li>
                <li>
                  Unicode and surrogate pairs:
                  <p>Some characters need two 16-bit values.</p>
                </li>
                <li>
                  Iterating characters:
                  <p>
                    Use `for/of` loops or the spread operator (...) to work
                    with each character.
                  </p>
                </li>
              </ul>

              <h2 class="text-xl font-bold mt-4">Key takeaways:</h2>
              <ul class="list-disc ml-6">
                <li>
                  Choose quote types (single, double, backticks) to avoid
                  conflicts with other code.
                </li>
                <li>
                  Use backticks for multiline strings and expression
                  interpolation.
                </li>
                <li>
                  Be mindful of Unicode characters and surrogate pairs when
                  working with string lengths.
                </li>
              </ul>
            </div>
          </section>
          <section>
            <h1 id="escape_sequence"
              class="font-bold bg-gray-300 text-blue-700 shadow-lg p-2 hover:bg-blue-500 hover:text-white text- rounded-md text-center text-3xl hover:underline mb-8 mt-32">
              Escape Sequences in JavaScript Strings:
            </h1>
            <div class="p-4 bg-gray-100">
              <p>
                Escape sequences allow the inclusion of special characters in
                JavaScript strings by using a backslash (\) followed by a
                specific character.
              </p>
              <p><strong>Common examples:</strong></p>
              <ul class="list-disc ml-6">
                <li>\n for a newline</li>
                <li>\' for a single quote within a single-quoted string</li>
                <li>\\ for a literal backslash</li>
              </ul>
              <p><strong>Generic escape sequences:</strong></p>
              <ul class="list-disc ml-6">
                <li>
                  \uXXXX for Unicode characters using a 4-digit hex code
                  (e.g., \u00A9 for the copyright symbol)
                </li>
                <li>\xXX for Unicode characters using a 2-digit hex code</li>
              </ul>
              <p>
                Backslashes before other characters are ignored unless future
                JavaScript versions define new escape sequences. ES5 allows
                backslashes to break strings across multiple lines.
              </p>
            </div>
            <table class="p-4 bg-gray-100">
              <caption class="font-bold text-lg">
                JavaScript Escape Sequences Table List
              </caption>
              <thead>
                <tr>
                  <th class="border border-gray-500 px-4 py-2">Sequence</th>
                  <th class="border border-gray-500 px-4 py-2">
                    Character represented
                  </th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td class="border border-gray-500 px-4 py-2">\0</td>
                  <td class="border border-gray-500 px-4 py-2">
                    The NUL character (\u0000)
                  </td>
                </tr>
                <tr>
                  <td class="border border-gray-500 px-4 py-2">\b</td>
                  <td class="border border-gray-500 px-4 py-2">
                    Backspace (\u0008)
                  </td>
                </tr>
                <tr>
                  <td class="border border-gray-500 px-4 py-2">\t</td>
                  <td class="border border-gray-500 px-4 py-2">
                    Horizontal tab (\u0009)
                  </td>
                </tr>
                <tr>
                  <td class="border border-gray-500 px-4 py-2">\n</td>
                  <td class="border border-gray-500 px-4 py-2">
                    Newline (\u000A)
                  </td>
                </tr>
                <tr>
                  <td class="border border-gray-500 px-4 py-2">\v</td>
                  <td class="border border-gray-500 px-4 py-2">
                    Vertical tab (\u000B)
                  </td>
                </tr>
                <tr>
                  <td class="border border-gray-500 px-4 py-2">\f</td>
                  <td class="border border-gray-500 px-4 py-2">
                    Form feed (\u000C)
                  </td>
                </tr>
                <tr>
                  <td class="border border-gray-500 px-4 py-2">\r</td>
                  <td class="border border-gray-500 px-4 py-2">
                    Carriage return (\u000D)
                  </td>
                </tr>
                <tr>
                  <td class="border border-gray-500 px-4 py-2">\"</td>
                  <td class="border border-gray-500 px-4 py-2">
                    Double quote (\u0022)
                  </td>
                </tr>
                <tr>
                  <td class="border border-gray-500 px-4 py-2">\'</td>
                  <td class="border border-gray-500 px-4 py-2">
                    Apostrophe or single quote (\u0027)
                  </td>
                </tr>
                <tr>
                  <td class="border border-gray-500 px-4 py-2">\\</td>
                  <td class="border border-gray-500 px-4 py-2">
                    Backslash (\u005C)
                  </td>
                </tr>
                <tr>
                  <td class="border border-gray-500 px-4 py-2">\xnn</td>
                  <td class="border border-gray-500 px-4 py-2">
                    The Unicode character specified by the two hexadecimal
                    digits nn
                  </td>
                </tr>
                <tr>
                  <td class="border border-gray-500 px-4 py-2">\unn</td>
                  <td class="border border-gray-500 px-4 py-2">
                    The Unicode character specified by the four hexadecimal
                    digits nnnn
                  </td>
                </tr>
                <tr>
                  <td class="border border-gray-500 px-4 py-2">\u{n}</td>
                  <td class="border border-gray-500 px-4 py-2">
                    The Unicode character specified by the codepoint n, where
                    n is one to six hexadecimal digits between 0 and 10FFFF
                    (ES6)
                  </td>
                </tr>
              </tbody>
            </table>
          </section>
          <section>
            <h1 id="boolean"
              class="font-bold bg-gray-300 text-blue-700 shadow-lg p-2 hover:bg-blue-500 hover:text-white text- rounded-md text-center text-3xl hover:underline mb-8 mt-32">
              Boolean Values in JavaScript:
            </h1>
            <div class="p-4 bg-gray-100">
              <p>
                Booleans in JavaScript work like small switches, showing
                either "true" or "false."
              </p>

              <h3 class="text-lg font-bold mt-2">How they're created:</h3>
              <ul class="list-disc ml-6">
                <li>Comparisons (e.g., a === 4 results in true or false)</li>
                <li>Directly using true or false</li>
              </ul>
              <h3 class="text-lg font-bold mt-2">Where they're used:</h3>
              <ul class="list-disc ml-6">
                <li>
                  Control structures like if/else statements to make decisions
                </li>
                <li>
                  Other situations where you need to check for truth or
                  falsehood
                </li>
              </ul>
              <h3 class="text-lg font-bold mt-2">Truthy and falsy values:</h3>
              <ul class="list-disc ml-6">
                <li>
                  JavaScript secretly converts values to booleans when needed.
                </li>
                <li>
                  "Truthy" values act like true (e.g., numbers, objects,
                  non-empty strings).
                </li>
                <li>
                  "Falsy" values act like false (e.g., undefined, null, 0, -0,
                  NaN, empty strings).
                </li>
              </ul>
              <h3 class="text-lg font-bold mt-2">Key operators:</h3>
              <ul class="list-disc ml-6">
                <li>&& (AND): True only if both sides are truthy.</li>
                <li>|| (OR): True if at least one side is truthy.</li>
                <li>
                  ! (NOT): Flips the boolean value (true becomes false, false
                  becomes true).
                </li>
              </ul>
              <h3 class="text-lg font-bold mt-2">Example:</h3>
              <pre class="bg-gray-200 p-2 rounded-lg">
            javascript
            if ((x === 0 && y === 0) || !(z === 0)) {
              // This code runs if:
              // - both x and y are zero, OR
              // - z is not zero
            }
                </pre>
              <p><strong>Remember:</strong></p>
              <ul class="list-disc ml-6">
                <li>
                  Choose <code>if (o !== null)</code> if you specifically need
                  to check for null.
                </li>
                <li>
                  Choose <code>if (o)</code> if you want to consider any
                  truthy value as true.
                </li>
              </ul>
            </div>
          </section>
          <section>
            <h1 id="null"
              class="font-bold bg-gray-300 text-blue-700 shadow-lg p-2 hover:bg-blue-500 hover:text-white text- rounded-md text-center text-3xl hover:underline mb-8 mt-32">
              Null in JavaScript
            </h1>
            <div>
              <h2>- What it is:</h2>
              <ul>
                <li>
                  A special value representing the intentional absence of any
                  object value.
                </li>
                <li>
                  Think of it like an empty placeholder or a "no value here"
                  sign.
                </li>
              </ul>

              <h2>- When to use it:</h2>
              <ul>
                <li>Initializing variables before assigning a real value.</li>
                <li>
                  Signaling that a function doesn't return a meaningful value.
                </li>
                <li>Clearing out object properties.</li>
                <li>Representing missing or unknown data.</li>
              </ul>

              <h2>- Key points:</h2>
              <ul>
                <li>
                  It's a primitive value, not an object (so you can't do
                  <code>null.something</code>).
                </li>
                <li>
                  It's one of the falsy values in JavaScript (meaning it acts
                  like <code>false</code> in certain cases).
                </li>
                <li>
                  Use <code>===</code> or <code>!==</code> to check for
                  <code>null</code> specifically, as it's different from
                  <code>undefined</code>.
                </li>
              </ul>
              <p>
                Using the typeof operator on null returns the string “object”,
                indicating that null can be thought of as a special object
                value that indicates “no object”
              </p>

              <h2>- Example:</h2>
              <pre>
              <code>
              let myName = null; // No name yet
              
              function findContact(name) {
                  if (name === null) {
                      return null; // No contact found
                  }
                  // ... search for contact ...
              }
              </code>
                </pre>

              <p><strong>Remember:</strong></p>
              <ul>
                <li>
                  Use <code>null</code> to intentionally signal the absence of
                  a value.
                </li>
                <li>
                  Use <code>undefined</code> when a variable hasn't been
                  assigned a value yet.
                </li>
              </ul>
            </div>
          </section>
          <section>
            <h1 id="undefine"
              class="font-bold bg-gray-300 text-blue-700 shadow-lg p-2 hover:bg-blue-500 hover:text-white text- rounded-md text-center text-3xl hover:underline mb-8 mt-32">
              What is Undifine in JAvaScript
            </h1>
            <div>
              <h3>Explanation of <code>undefined</code> in JavaScript:</h3>
              <div>
                <h4>Key Points:</h4>
                <ul>
                  <li><strong>Represents the absence of a value.</strong></li>
                  <li>
                    <strong>Occurs in these cases:</strong>
                    <ul>
                      <li>
                        A variable is declared but not assigned a value.
                      </li>
                      <li>A function doesn't return a value explicitly.</li>
                      <li>A property doesn't exist in an object.</li>
                      <li>An item is not found in an array.</li>
                    </ul>
                  </li>
                  <li>
                    <strong>Strict Equality:</strong> Use <code>===</code> to
                    check if something is <code>undefined</code> (not
                    <code>==</code>).
                  </li>
                </ul>
              </div>
              <div>
                <h4>Important Notes:</h4>
                <ul>
                  <li>
                    <strong>Different from <code>null</code>:</strong>
                    <code>null</code> signifies intentional non-existence,
                    while <code>undefined</code> means a value hasn't been
                    assigned yet.
                  </li>
                  <li>
                    <strong>Checking for <code>undefined</code>:</strong> Use
                    <code>typeof</code> or strict equality:
                    <pre><code>if (typeof x === "undefined") { /* ... */ }
              if (x === undefined) { /* ... */ }</code></pre>
                  </li>
                  <li>
                    <strong>Global Property:</strong>
                    <code>undefined</code> is a global property, but avoid
                    redefining it.
                  </li>
                </ul>
              </div>
              <div>
                <h4>Example:</h4>
                <pre><code>let myVariable;        // Declared, but not assigned (undefined)
              function myFunction() {} // Doesn't return a value (implicitly returns undefined)
              const myObject = {};   // Property "name" doesn't exist (myObject.name is undefined)
                  </code></pre>
              </div>
              <p>
                <strong>Remember:</strong> Understanding
                <code>undefined</code> is essential for handling potential
                errors and writing robust JavaScript code.
              </p>
              <p>
                If you apply the typeof operator to the undefined value, it
                returns “undefined”, indicating that this value is the sole
                member of a special type
              </p>
            </div>
          </section>
          <section>
            <h1 id="symbol"
              class="font-bold bg-gray-300 text-blue-700 shadow-lg p-2 hover:bg-blue-500 hover:text-white text- rounded-md text-center text-3xl hover:underline mb-8 mt-32">
              Symbols in JavaScript
            </h1>
            <div>
              <div>
                <h4>Purpose of Symbols:</h4>
                <p>
                  Symbols are a unique and immutable primitive data type.
                  Symbols are special entities introduced in ES6 used as
                  property names in JavaScript objects. Before ES6, properties
                  were exclusively named with strings.
                </p>
              </div>
              <div>
                <h4>Symbol Creation:</h4>
                <p>
                  To create a Symbol, you use the
                  <code>Symbol()</code> function. For instance:
                </p>
                <pre><code>let symname = Symbol("propertyName"); // Creating a Symbol for a property name</code></pre>
              </div>
              <div>
                <h4>Usage in Objects:</h4>
                <p>
                  Symbols can be used as property names in objects alongside
                  strings, preventing conflicts between properties:
                </p>
                <pre><code>const obj = {};
              obj[symname] = 2; // Adding a property with a Symbol name to an object</code></pre>
              </div>
              <div>
                <h4>Unique Values:</h4>
                <p>
                  Every time <code>Symbol()</code> is called with the same
                  argument, it returns a unique Symbol value. This uniqueness
                  ensures safe usage as property names without accidentally
                  overwriting existing properties.
                </p>
              </div>
              <div>
                <h4>Global Symbol Registry:</h4>
                <p>
                  JavaScript provides <code>Symbol.for()</code> to create and
                  share Symbols globally, ensuring consistency:
                </p>
                <pre><code>let s = Symbol.for("shared"); // Creates or retrieves a shared Symbol
              let t = Symbol.for("shared");
              s === t; // Evaluates to true as both symbols refer to the same value</code></pre>
              </div>
              <p>
                Understanding Symbols helps avoid property conflicts and
                facilitates safer property naming, especially when sharing
                code or defining specific functionalities in JavaScript.
              </p>
            </div>
          </section>
          <section>
            <div class="rounded-lg shadow-md p-8">
              <h2 id="bigint"
                class="font-bold bg-gray-300 text-blue-700 shadow-lg p-2 hover:bg-blue-500 hover:text-white text- rounded-md text-center text-3xl hover:underline mb-8 mt-32">
                BigInt in JavaScript
              </h2>
              <p class="mb-4">
                In JavaScript,
                <code class="bg-gray-200 px-1 rounded">bigint</code> is a
                primitive data type introduced in ECMAScript 2020 (ES11) to
                represent integers of arbitrary precision. It allows the
                storage and manipulation of integers larger than the maximum
                value that can be represented by the
                <code class="bg-gray-200 px-1 rounded">number</code> primitive
                type, which is limited to
                <code class="bg-gray-200 px-1 rounded">Number.MAX_SAFE_INTEGER</code>.
              </p>

              <h3 class="text-lg font-bold mb-2">Declaration</h3>
              <p class="mb-4">
                To create a
                <code class="bg-gray-200 px-1 rounded">bigint</code>, you can
                append an <code class="bg-gray-200 px-1 rounded">n</code> to
                the end of an integer literal or use the
                <code class="bg-gray-200 px-1 rounded">BigInt()</code>
                constructor:
              </p>
              <pre class="bg-gray-200 rounded-lg p-4 mb-4">
                    <code>
                        const bigIntNumber = 123n;
                        const anotherBigInt = 
                        BigInt("9007199254740991");
                         // Using BigInt() constructor
                    </code>
                </pre>

              <h3 class="text-lg font-bold mb-2">Usage</h3>
              <p class="mb-4">
                BigInts can be used for arithmetic operations just like
                regular numbers:
              </p>
              <pre class="bg-gray-200 rounded-lg p-4 mb-4">
                  <code>
                    const result =
                    1234567890123456789012345678901234567890n + 1n;
                   console.log(result); 
                   // Output: 1234567890123456789012345678901234567891n                  
                </code>                   
                </pre>
            </div>
          </section>
        </div>
        <!-- Reference datatypes -->
        <div class="reference">
          <section id="object">
            <h2
              class="font-bold bg-gray-300 text-blue-700 shadow-lg p-2 hover:bg-blue-500 hover:text-white text- rounded-md text-center text-3xl hover:underline mb-8 mt-32">
              Object in JavaScript
            </h2>
            <p>An object in JavaScript is a collection of key-value pairs.</p>
            <p>
              In JavaScript, an object is a collection of key-value pairs that
              represents a real-world entity or concept. It's a fundamental
              data structure that allows you to organize and structure your
              data in a meaningful way
            </p>
            <pre><code>
          const person = {
            name: 'John',
            age: 30
          };
              </code></pre>
          </section>

          <!-- Array -->
          <section id="array">
            <h2
              class="font-bold bg-gray-300 text-blue-700 shadow-lg p-2 hover:bg-blue-500 hover:text-white text- rounded-md text-center text-3xl hover:underline mb-8 mt-32">
              JS Array
            </h2>
            <p>An array is an ordered collection of values.</p>
            <p>
              In JavaScript, an array is a special kind of object that's used
              to store a list of values, or elements. It's like a container
              that holds multiple items in an ordered sequence
            </p>
            <pre><code>
          const numbers = [1, 2, 3, 4, 5];
              </code></pre>
          </section>

          <!-- Function -->
          <section id="function">
            <h2
              class="font-bold bg-gray-300 text-blue-700 shadow-lg p-2 hover:bg-blue-500 hover:text-white text- rounded-md text-center text-3xl hover:underline mb-8 mt-32">
              JS Function
            </h2>

            <p>
              In JavaScript, a function is a reusable block of code that
              performs a specific task. It's a fundamental building block that
              helps organize and structure your code, making it more modular,
              readable, and maintainable
            </p>
            <pre><code>
function greet(name) {
  return `Hello, ${name}!`;
}
    </code></pre>
          </section>

          <!-- Date -->
          <section id="date">
            <h2
              class="font-bold bg-gray-300 text-blue-700 shadow-lg p-2 hover:bg-blue-500 hover:text-white text- rounded-md text-center text-3xl hover:underline mb-8 mt-32">
              JS Date
            </h2>
            <p>
              The Date object is used to work with dates and times in
              JavaScript.
            </p>
            <pre><code>
const currentDate = new Date();
    </code></pre>
          </section>

          <!-- RegExp -->
          <section id="regex">
            <h2
              class="font-bold bg-gray-300 text-blue-700 shadow-lg p-2 hover:bg-blue-500 hover:text-white text- rounded-md text-center text-3xl hover:underline mb-8 mt-32">
              JS Regular Expression
            </h2>
            <p>
              Regular expressions are patterns used to match character
              combinations in strings.In JavaScript, a regular expression
              (regex or RegExp) is a sequence of characters that define a
              search pattern. It's a powerful tool for matching, searching,
              and manipulating text strings
            </p>
            <pre><code>
const regex = /apple/;   //Enclose the pattern in forward slashes
const str = "apple tree";
console.log(regex.test(str)); // true

    </code></pre>
          </section>

          <!-- Map -->
          <section id="map">
            <h2
              class="font-bold bg-gray-300 text-blue-700 shadow-lg p-2 hover:bg-blue-500 hover:text-white text- rounded-md text-center text-3xl hover:underline mb-8 mt-32">
              JS Map
            </h2>
            <p>
              In JavaScript, a Map object is a collection of key-value pairs,
              similar to an object but with distinct features that make it
              valuable in specific scenarios.
            </p>
            <ul>
              <li>Map keys can be of any data type.</li>
              <li>Map objects maintain the insertion order of keys</li>
              <li>Each key in a Map must be unique.</li>
            </ul>
            <pre><code>
const myMap = new Map();
myMap.set('key1', 'value1');

console.log(myMap.get(key1)); // Output: "value1"
    </code></pre>
          </section>

          <!-- Set -->
          <section id="set">
            <h2
              class="font-bold bg-gray-300 text-blue-700 shadow-lg p-2 hover:bg-blue-500 hover:text-white text- rounded-md text-center text-3xl hover:underline mb-8 mt-32">
              JS Set
            </h2>

            <p>
              In JavaScript, a Set object is a collection of unique values.
              It's designed to store values of any data type, ensuring that
              each value appears only once within the set.
            </p>
            <ul>
              <li>Each value in a Set must be unique.</li>
              <li>
                Unlike objects or Maps, Sets don't have key-value pairs.
              </li>
              <li>Sets maintain the order in which values were added</li>
            </ul>
            <pre><code>
const mySet = new Set();
mySet.add("apple");

console.log(mySet.has("apple")); // Output: true
    </code></pre>
          </section>

          <!-- Promise -->
          <section id="promise">
            <h2
              class="font-bold bg-gray-300 text-blue-700 shadow-lg p-2 hover:bg-blue-500 hover:text-white text- rounded-md text-center text-3xl hover:underline mb-8 mt-32">
              JS Promise
            </h2>
            <p>
              A Promise is an object representing the eventual completion or
              failure of an asynchronous operation.
            </p>
            <em>
              In JavaScript, a promise is an object that represents the
              eventual result of an asynchronous operation. It's a mechanism
              for handling the completion (or failure) of a task that might
              take some time, without blocking the execution of other cod</em>
            <pre><code>
                // Create a promise that resolves after 2 seconds
                const myPromise = new Promise((resolve, reject) => {
                  setTimeout(() => {
                    resolve("Hello, after 2 seconds!");
                  }, 2000);
                });
                
                // Handle the promise's outcome
                myPromise
                  .then(message => {
                    console.log(message); // Output: "Hello, after 2 seconds!"
                  })
                  .catch(error => {
                    console.error("Something went wrong:", error);
                  });
                
                console.log("This will log first."); // Executes immediately
                
    </code></pre>
          </section>

          <!-- Math -->
          <section id="math">
            <h2
              class="font-bold bg-gray-300 text-blue-700 shadow-lg p-2 hover:bg-blue-500 hover:text-white text- rounded-md text-center text-3xl hover:underline mb-8 mt-32">
              JS Math
            </h2>
            <p>
              The Math object in JavaScript is a built-in object that provides
              a collection of mathematical constants and functions for
              performing numerical calculations.
            </p>
            <pre><code>
                const squareRoot = 5
                const result = Math.sqrt(25);
                console.log(result)   //5
    </code></pre>
          </section>

          <!-- Error -->
          <section id="error">
            <h2
              class="font-bold bg-gray-300 text-blue-700 shadow-lg p-2 hover:bg-blue-500 hover:text-white text- rounded-md text-center text-3xl hover:underline mb-8 mt-32">
              JS Error
            </h2>
            <p>
              In JavaScript, an error object is a special type of object that
              represents an error or exception that occurred during code
              execution. It provides information about the error, helping you
              identify and handle problems in your code.
            </p>
            <pre><code>
throw new Error('Something went wrong!');

const myError = new TypeError("Invalid argument type");
console.log(myError) 
    </code></pre>
          </section>

          <!-- Global Object -->
          <section id="global">
            <h2
              class="font-bold bg-gray-300 text-blue-700 shadow-lg p-2 hover:bg-blue-500 hover:text-white text- rounded-md text-center text-3xl hover:underline mb-8 mt-32">
              JS Global Object
            </h2>
            <p>
              The global object is an object in JavaScript that contains
              variables, functions, and other objects that are globally
              accessible. The global object is the highest-level container
              that holds all global variables, functions, and objects, giving
              a common context for running code.
            </p>
            <pre><code>
          console.log(window.document);
    </code></pre>
          </section>
        </div>
        <div class="variables">
          <section>
            <h1 id="variable"
              class="font-bold bg-gray-300 text-blue-700 shadow-lg p-2 hover:bg-blue-500 hover:text-white text- rounded-md text-center text-3xl hover:underline mb-8 mt-32">
              JavaScript Variables
            </h1>
            <p>
              <strong>Storage Units:</strong> Variables are named storage
              locations holding various data types like numbers, strings,
              objects, or functions.
            </p>
            <p>
              <strong>Mutable Containers:</strong> They hold information that
              can be modified or reassigned during program execution.
            </p>

            <h2>Variable Declaration</h2>
            <p>
              <strong>Keyword Usage:</strong> JavaScript offers
              <code>var</code>, <code>let</code>, and
              <code>const</code> keywords for variable declaration, each with
              different behavior.
            </p>
            <p>
              <strong>Variable Initialization:</strong> Best practice involves
              assigning an initial value when declaring a variable, aiding in
              clarity and functionality.
            </p>
          </section>
          <section id="var">
            <h2
              class="font-bold bg-gray-300 text-blue-700 shadow-lg p-2 hover:bg-blue-500 hover:text-white text- rounded-md text-center text-3xl hover:underline mb-8 mt-32">
              Cerating Variable using <em>var</em>
            </h2>
            <p>
              In JavaScript, var is a keyword used to declare variables.
              However, it's considered a legacy keyword with some potential
              pitfalls, and its use is generally discouraged in modern
              JavaScript development
            </p>
            <h2 class="font-bold text-2xl text-amber-950">
              Key Characteristics of var:
            </h2>

            <p>
              Function Scope: Variables declared with var have function scope,
              meaning they are accessible within the entire function where
              they are declared, even if defined within a block (e.g., if
              statement, for loop). Hoisting: Variables declared with var are
              hoisted to the top of their enclosing function, meaning they can
              be used before they are declared. However, their value will be
              undefined until the actual declaration is reached. Global Scope:
              If a variable is declared with var outside of any function, it
              becomes a global variable, accessible from anywhere in the code.
              This can lead to naming conflicts and unintended side effects.
            </p>
            <h2 class="font-bold text-2xl text-amber-950">
              Why var Is Discouraged:
            </h2>
            <p>
              Scope Issues: Function scope can sometimes lead to unexpected
              behavior, especially when dealing with nested functions and
              blocks. Global Variables: Accidental creation of global
              variables can pollute the global namespace and make code harder
              to maintain. Hoisting Confusion: Hoisting can sometimes be
              confusing, especially for beginners, as it can make it seem like
              variables are declared before they actually are.
            </p>
            <h2 class="font-bold text-2xl text-amber-950">
              Preferred Alternatives:
            </h2>
            <p>
              let: Introduced in ES6, let has block scope, meaning variables
              declared with let are only accessible within the block where
              they are declared. This provides more granular control over
              variable visibility and prevents unintended global pollution.
              const: Also introduced in ES6, const creates constants that
              cannot be reassigned after their initial declaration. This helps
              ensure value consistency and prevents accidental modifications
            </p>
            <h2 class="font-bold text-2xl text-amber-950">
              Modern Best Practices:
            </h2>
            <p>
              Use let for variables that need to be reassigned. Use const for
              variables that should remain constant. Avoid var in new code.
              Understand scope rules to prevent unintended variable behavior.
              Prefer modules to organize code and avoid global variables.
            </p>
          </section>
          <section>
            <h2 id="let"
              class="font-bold bg-gray-300 text-blue-700 shadow-lg p-2 hover:bg-blue-500 hover:text-white text- rounded-md text-center text-3xl hover:underline mb-8 mt-32">
              Cerating Variable using <em>let</em>
            </h2>
            <p>
              In JavaScript, let is a keyword used to declare variables with
              block scope. It was introduced in ES6 (ECMAScript 2015) to
              provide more control over variable scoping and avoid common
              pitfalls associated with var.
            </p>

            <h2>Key Characteristics:</h2>

            <b>Block Scope:</b> Variables declared with let are only
            accessible within the block where they are declared (usually
            enclosed in curly braces {}).
            <b>Temporal Dead Zone (TDZ):</b> Before a let variable is
            declared, it's in the TDZ, meaning you can't access it or use it.
            This prevents errors caused by hoisting.
            <b>Re-declaration:</b> You can't redeclare a let variable within
            the same block, but you can redeclare it in a different block.
            <b>Hoisting:</b> Unlike var variables, let variables are not
            hoisted to the top of their scope. They are only available after
            their declaration.

            <pre>
  <code>
    if (true) {
      let x = 10; // x is only accessible within this block
      console.log(x); // Output: 10
    }
    
    console.log(x); // Error: x is not defined here (outside the block)
  </code>
</pre>
            <h2>Benefits of Using let:</h2>

            <b>Prevents Accidental Globals:</b> Ensures variables are not
            accidentally declared in the global scope, reducing naming
            conflicts and potential side effects. Encourages Better Code
            Organization: Promotes modularity and code readability by limiting
            variable visibility to their relevant blocks.
            <b>Avoids Hoisting Issues</b>: Prevents potential errors caused by
            the unexpected behavior of hoisted var variables. Enables Temporal
            Dead Zone: Catches errors early by preventing access to variables
            before they are declared.
            <h2>When to Use let:</h2>

            <b>Prefer let over var in most cases:</b> It's generally
            recommended to use let for variable declarations to ensure clearer
            scoping and avoid common pitfalls.
            <b>Block-Scoped Variables: </b>Use let when you want a variable to
            be accessible only within a specific block of code.
            <b>Loop Variables:</b> Use let to create loop variables that are
            confined to the loop's iteration, preventing unintended side
            effects. Function-Scoped Variables: Declare variables with let
            within functions to limit their scope to the function body.
          </section>

          <section>
            <h2 id="const"
              class="font-bold bg-gray-300 text-blue-700 shadow-lg p-2 hover:bg-blue-500 hover:text-white text- rounded-md text-center text-3xl hover:underline mb-8 mt-32">
              Cerating Variable using <em>const</em>
            </h2>
            <p>
              In JavaScript, const is a keyword used to declare variables that
              cannot be reassigned after their initial declaration. It's a way
              to create block-scoped, read-only constants, ensuring that their
              values remain consistent throughout their scope.
            </p>

            <h3>Key Characteristics:</h3>
            <ul>
              <li>
                <strong>Block-Scoped:</strong> Variables declared with const
                are only accessible within the block where they're declared
                (usually a pair of curly braces {}).
              </li>
              <li>
                <strong>Read-Only:</strong> Their values cannot be changed
                after the initial assignment. Attempting to reassign them
                results in a runtime error.
              </li>
              <li>
                <strong>Hoisting:</strong> While const declarations are not
                hoisted to the top of their scope like var declarations, they
                are still initialized with a value of undefined before the
                code execution reaches their line.
              </li>
            </ul>

            <h3>Example:</h3>
            <pre><code>
            function myFunction() {
              const age = 30; // age is a constant within this function
              age = 40; // This would cause an error
            }
            
            const name = "Alice"; // name is a constant in the global scope
            let greeting = "Hello"; // let allows reassignment
            greeting = "Hi"; // This is allowed
              </code></pre>
            <p>Use code with caution. <a href="#">Learn more</a></p>

            <h3>Benefits of Using const:</h3>
            <ul>
              <li>
                <strong>Prevents Accidental Reassignments:</strong> Protects
                variables from unintended changes, reducing bugs and making
                code more predictable.
              </li>
              <li>
                <strong>Promotes Clarity and Immutability:</strong> Declares
                variables as constants, making their intent clear and
                signaling that they shouldn't be modified.
              </li>
              <li>
                <strong>Encourages Functional Programming Style:</strong>
                Aligns with functional programming principles where data is
                immutable, leading to more robust and easier-to-reason-about
                code.
              </li>
            </ul>

            <h3>When to Use const:</h3>
            <p>Consider using const in these scenarios:</p>
            <ul>
              <li>
                Variables that should never change: Values like mathematical
                constants, configuration settings, or API endpoints.
              </li>
              <li>
                Loop counters and conditional variables: Inside loops or
                conditional blocks to ensure their values remain consistent
                within those specific contexts.
              </li>
              <li>
                Function arguments and return values: To prevent accidental
                modifications within functions, promoting better
                encapsulation.
              </li>
              <li>
                Default values for function parameters: To provide clear and
                unchanging defaults.
              </li>
              <li>
                Object properties: To create objects with read-only
                properties, enforcing data integrity.
              </li>
            </ul>

            <h3>General Recommendation:</h3>
            <p>
              Prefer using const by default for variable declarations unless
              you specifically need to reassign the variable later. This
              practice helps write more secure, maintainable, and predictable
              code.
            </p>
          </section>
        </div>
        <div id="expression">
          <h2 id="const"
            class="font-bold bg-gray-300 text-blue-700 shadow-lg p-2 hover:bg-blue-500 hover:text-white text- rounded-md text-center text-3xl hover:underline mb-8 mt-32">
            Expression in JavaScript
          </h2>
          <section>
            <p>
              In JavaScript, an expression is a piece of code that produces a
              value. It's a fundamental building block that instructs the
              JavaScript engine to perform operations and calculations.
            </p>

            <h3>Key Characteristics:</h3>
            <ul>
              <li>
                <strong>Evaluation:</strong> When an expression is executed,
                it's evaluated to a value.
              </li>
              <li>
                <strong>Assignment:</strong> Expressions can be assigned to
                variables to store their results.
              </li>
              <li>
                <strong>Function Arguments:</strong> Expressions can be passed
                as arguments to functions.
              </li>
              <li>
                <strong>Control Flow Statements:</strong> Expressions are used
                in conditional statements (e.g., <code>if</code>) and loops
                (e.g., <code>for</code>) to control program execution.
              </li>
            </ul>

            <h3>Types of Expressions:</h3>
            <ul>
              <li>
                <strong>Literal Expressions:</strong> Simple values like
                numbers (e.g., <code>42</code>), strings (e.g.,
                <code>"Hello"</code>), booleans (e.g., <code>true</code>), and
                <code>null</code>.
              </li>
              <li>
                <strong>Variable References:</strong> Names of variables that
                hold values (e.g., <code>age</code>, <code>total</code>).
              </li>
              <li>
                <strong>Operator Expressions:</strong> Combinations of values
                and operators (e.g., <code>2 + 3</code>, <code>x * y</code>,
                <code>name === "Alice"</code>).
              </li>
              <li>
                <strong>Function Calls:</strong> Expressions that invoke
                functions and return their results (e.g.,
                <code>Math.sqrt(16)</code>,
                <code>myFunction(arg1, arg2)</code>).
              </li>
              <li>
                <strong>Object Literals:</strong> Expressions that create
                objects (e.g., <code>{ name: "Alice", age: 30 }</code>).
              </li>
              <li>
                <strong>Array Literals:</strong> Expressions that create
                arrays (e.g., <code>[1, 2, 3]</code>).
              </li>
            </ul>

            <h3>Examples:</h3>
            <pre><code>
            // Arithmetic expression
            const result = 5 + 3 * 2; // Evaluates to 11
            
            // String concatenation expression
            const greeting = "Hello, " + name + "!";
            
            // Conditional expression
            const isAdult = age >= 18;
            
            // Function call expression
            const square = Math.pow(4, 2); // Evaluates to 16
            
            // Object literal expression
            const person = { name: "Bob", age: 25 };
              </code></pre>

            <h3>Key Points:</h3>
            <ul>
              <li>
                Expressions are the heart of JavaScript's computation and
                logic.
              </li>
              <li>
                They can be combined and nested to create more complex logic.
              </li>
              <li>
                Understanding expressions is essential for writing effective
                JavaScript code.
              </li>
            </ul>
          </section>
          <section>
            <h2 id="primaryExpression"
              class="font-bold bg-gray-300 text-blue-700 shadow-lg p-2 hover:bg-blue-500 hover:text-white text- rounded-md text-center text-3xl hover:underline mb-8 mt-32">
              Primary Expression in JS
            </h2>
            <p>
              In JavaScript, a <strong>primary expression</strong> is the
              building block of more complex expressions. It's the simplest
              form of expression that evaluates to a single value without
              requiring further decomposition.
            </p>

            <h3>Definition:</h3>
            <ul>
              <li>
                A primary expression evaluates to a single value without
                needing further operations or calculations.
              </li>
              <li>
                It essentially represents the "atoms" of JavaScript
                expressions.
              </li>
            </ul>

            <h3>Types of Primary Expressions:</h3>
            <ol>
              <li>
                <strong>Literals:</strong> Direct representations of values:
                <ul>
                  <li>
                    Numeric literals: <code>123</code>, <code>3.14</code>,
                    <code>-0.5</code>
                  </li>
                  <li>
                    String literals: <code>"Hello"</code>,
                    <code>'World'</code>, <code>''</code> (empty string)
                  </li>
                  <li>
                    Boolean literals: <code>true</code>, <code>false</code>
                  </li>
                  <li>
                    Null and undefined: <code>null</code>,
                    <code>undefined</code>
                  </li>
                </ul>
              </li>
              <li>
                <strong>Identifiers:</strong> References to named entities
                like variables, functions, or object properties:
                <ul>
                  <li>
                    Variable names: <code>x</code>, <code>myFunction</code>,
                    <code>personObj</code>
                  </li>
                  <li>
                    Function names: <code>Math.max</code>,
                    <code>setTimeout</code>, <code>myFunction</code>
                  </li>
                  <li>
                    Object property names: <code>person.name</code>,
                    <code>obj.data</code>, <code>arr[1]</code>
                  </li>
                </ul>
              </li>
              <li>
                <strong>Grouping Expressions:</strong> Expressions enclosed in
                parentheses that are evaluated as a single unit:
                <ul>
                  <li><code>(2 + 3) * 4</code></li>
                  <li><code>(Math.cos(PI/2))</code></li>
                  <li><code>(obj?.property ?: defaultValue)</code></li>
                </ul>
              </li>
              <li>
                <strong>This Expression:</strong> Refers to the current object
                within a function or method:
                <ul>
                  <li>
                    <code>this.name</code> - inside a person object
                    constructor
                  </li>
                  <li>
                    <code>this.update()</code> - inside a method of an object
                  </li>
                </ul>
              </li>
              <li>
                <strong>Super Expression:</strong> In class methods, refers to
                the parent class:
                <ul>
                  <li>
                    <code>super.method()</code> - calls a method in the parent
                    class
                  </li>
                </ul>
              </li>
            </ol>

            <p>
              These are the main types of primary expressions in JavaScript.
              Understanding them is crucial for building more intricate and
              functional expressions that form the backbone of your code.
            </p>

            <h3>Additional Note:</h3>
            <ul>
              <li>
                Some sources include keywords like <code>true</code>,
                <code>false</code>, and <code>null</code> as separate
                categories within primary expressions.
              </li>
              <li>
                The specific types and functionalities may vary depending on
                the JavaScript version and environment.
              </li>
            </ul>

            <p>
              Remember, primary expressions are the fundamental building
              blocks, and you can combine them using operators and other
              constructs to create complex and powerful expressions in your
              JavaScript code.
            </p>
          </section>
          <section>
            <h2 id="functionDefinitionExpression"
              class="font-bold bg-gray-300 text-blue-700 shadow-lg p-2 hover:bg-blue-500 hover:text-white text- rounded-md text-center text-3xl hover:underline mb-8 mt-32">
              Function Definition Expression
            </h2>

            <p>
              In JavaScript, a function definition expression is a way to
              create a function as an expression, often assigning it to a
              variable or using it as part of another expression.
            </p>

            <h3>Key Characteristics:</h3>
            <ul>
              <li>
                <strong>Defined using the <code>function</code> keyword</strong>, followed by optional parentheses for
                parameters and a code
                block enclosed in curly braces.
              </li>
              <li>
                <strong>Can be named or anonymous</strong> (without a name).
              </li>
              <li>
                <strong>Return values using the
                  <code>return</code> statement</strong>
                (optional).
              </li>
              <li>
                <strong>Can be assigned to variables, passed as arguments, or used
                  within other expressions</strong>.
              </li>
            </ul>

            <h3>Syntax:</h3>
            <pre><code>
                // Named function definition expression (assigned to a variable)
                const myFunction = function name(parameters) {
                  // Function body
                  return value; // Optional
                };
            
                // Anonymous function definition expression (used directly)
                const result = (function() {
                  // Function body
                  return value;
                })();
              </code></pre>

            <h3>Example:</h3>
            <pre><code>
                // Named function:
                const greet = function(name) {
                  console.log("Hello, " + name + "!");
                };
            
                // Anonymous function:
                const numbers = [1, 2, 3, 4];
                const doubledNumbers = numbers.map(function(number) {
                  return number * 2;
                });
              </code></pre>

            <h3>Benefits:</h3>
            <ul>
              <li>
                <strong>Flexibility:</strong> Function definition expressions
                can be used dynamically and creatively in code.
              </li>
              <li>
                <strong>Function Hoisting:</strong> Named function expressions
                are hoisted, meaning they can be used before they're defined
                in the code (although their execution is still sequential).
              </li>
              <li>
                <strong>Closures:</strong> They can create closures, which
                capture variables from their surrounding scope, even after the
                outer function has returned.
              </li>
            </ul>

            <h3>Common Use Cases:</h3>
            <ul>
              <li>
                <strong>Assigning functions to variables:</strong> For dynamic
                function assignment or later execution.
              </li>
              <li>
                <strong>Creating callbacks for event handlers:</strong> To
                respond to events in asynchronous programming.
              </li>
              <li>
                <strong>Immediately Invoked Function Expressions (IIFEs):</strong>
                To create private scopes or execute code immediately.
              </li>
              <li>
                <strong>Higher-order functions:</strong> Functions that take
                functions as arguments or return functions, enabling powerful
                functional programming patterns.
              </li>
            </ul>

            <p>
              <strong>Remember:</strong> Function definition expressions offer
              a powerful way to create functions dynamically and combine them
              with other expressions for flexible and expressive code in
              JavaScript.
            </p>
          </section>
          <section>
            <h2 id="propertyAccessExpression"
              class="font-bold bg-gray-300 text-blue-700 shadow-lg p-2 hover:bg-blue-500 hover:text-white text- rounded-md text-center text-3xl hover:underline mb-8 mt-32">
              Property Access Expression
            </h2>
            <p>
              In JavaScript, property access expressions are used to retrieve
              values from object properties, while conditional property access
              offers a safer way to handle potential
              <code>undefined</code> values.
            </p>

            <h3>Property Access Expressions:</h3>
            <ul>
              <li>
                <strong>Purpose:</strong> To access and retrieve values stored
                within object properties.
              </li>
              <li>
                <strong>Notations:</strong>
                <ul>
                  <li>
                    <strong>Dot notation:</strong>
                    <code>object.property</code>
                  </li>
                  <li>
                    <strong>Bracket notation:</strong>
                    <code>object["property"]</code> (especially for dynamic
                    property names or computed property names)
                  </li>
                </ul>
              </li>
            </ul>

            <h3>Example:</h3>
            <pre><code>
                const person = { name: "Alice", age: 30 };
                const name = person.name; // Dot notation
                const age = person["age"]; // Bracket notation
              </code></pre>

            <h3>Conditional Property Access (<code>?.</code> Operator):</h3>
            <ul>
              <li>
                <strong>Purpose:</strong> Safely access properties that might
                be <code>undefined</code> without throwing errors.
              </li>
              <li><strong>Syntax:</strong> <code>object?.property</code></li>
              <li>
                <strong>Behavior:</strong>
                <ul>
                  <li>
                    If <code>object</code> is <code>undefined</code> or
                    <code>null</code>, the entire expression evaluates to
                    <code>undefined</code> without errors.
                  </li>
                  <li>
                    If <code>object</code> is not <code>undefined</code> or
                    <code>null</code>, it proceeds to access the property as
                    usual.
                  </li>
                </ul>
              </li>
            </ul>

            <h3>Example:</h3>
            <pre><code>
                const user = getUserFromDatabase(); // Might be null or undefined
                const displayName = user?.profile?.displayName; // Safely accesses nested properties
              </code></pre>

            <h3>Benefits of Conditional Property Access:</h3>
            <ul>
              <li>
                <strong>Prevents TypeErrors:</strong> Avoids errors when
                accessing properties of potentially
                <code>undefined</code> objects.
              </li>
              <li>
                <strong>Concise Code:</strong> Offers a cleaner and more
                concise way to handle potential <code>undefined</code> values
                compared to traditional conditional checks.
              </li>
              <li>
                <strong>Chaining:</strong> Can be chained to access nested
                properties safely.
              </li>
            </ul>

            <h3>Common Use Cases:</h3>
            <ul>
              <li>
                <strong>Handling Optional Properties:</strong> When working
                with objects that might have missing properties.
              </li>
              <li>
                <strong>Working with Nested Structures:</strong> Safely
                navigating through nested objects without errors.
              </li>
              <li>
                <strong>API Responses:</strong> Handling data from APIs that
                might have incomplete or missing data.
              </li>
            </ul>

            <h3>Key Points:</h3>
            <ul>
              <li>
                Property access expressions are essential for working with
                object data in JavaScript.
              </li>
              <li>
                Conditional property access provides a safe and convenient way
                to handle potential <code>undefined</code> values, leading to
                more robust and error-free code.
              </li>
            </ul>
          </section>
          <section>
            <h2 id="invocationExpression"
              class="font-bold bg-gray-300 text-blue-700 shadow-lg p-2 hover:bg-blue-500 hover:text-white text- rounded-md text-center text-3xl hover:underline mb-8 mt-32">
              Innovation Expressions
            </h2>

            <ul>
              <li>
                <strong>Purpose:</strong> To call functions and execute their
                code.
              </li>
              <li>
                <strong>Syntax:</strong> <code>functionName(arguments)</code>
              </li>
            </ul>

            <h3>Example:</h3>
            <pre><code>
                const result = Math.sqrt(16); // Calls the Math.sqrt function
                const greeting = greet("Alice"); // Calls the greet function with argument "Alice"
              </code></pre>

            <h3>Conditional Invocation (<code>?.</code>() Operator):</h3>
            <ul>
              <li>
                <strong>Purpose:</strong> Safely call functions only if the
                object or value is not <code>undefined</code> or
                <code>null</code>, avoiding potential errors.
              </li>
              <li>
                <strong>Syntax:</strong> <code>object?.methodName()</code>
              </li>
              <li>
                <strong>Behavior:</strong>
                <ul>
                  <li>
                    If <code>object</code> is <code>undefined</code> or
                    <code>null</code>, the entire expression evaluates to
                    <code>undefined</code> without attempting the function
                    call.
                  </li>
                  <li>
                    If <code>object</code> is not <code>undefined</code> or
                    <code>null</code>, it proceeds to call the function as
                    usual.
                  </li>
                </ul>
              </li>
            </ul>

            <h3>Example:</h3>
            <pre><code>
                const user = getUserFromDatabase(); // Might be null or undefined
                const formattedName = user?.getFormattedName(); // Only calls getFormattedName if user exists
              </code></pre>

            <h3>Benefits of Conditional Invocation:</h3>
            <ul>
              <li>
                <strong>Prevents TypeErrors:</strong> Avoids errors when
                calling methods on potentially <code>undefined</code> objects.
              </li>
              <li>
                <strong>Concise Code:</strong> Offers a cleaner and more
                concise way to handle potential <code>undefined</code> values
                compared to traditional conditional checks.
              </li>
              <li>
                <strong>Chaining:</strong> Can be chained to conditionally
                call multiple methods or access nested properties.
              </li>
            </ul>

            <h3>Key Points:</h3>
            <ul>
              <li>
                Invocation expressions are essential for executing functions
                and their code.
              </li>
              <li>
                Conditional invocation provides a safety net when working with
                potentially <code>undefined</code> values, leading to more
                robust and error-free code.
              </li>
              <li>
                While conditional invocation is often used with methods, it
                can also be used with any callable object, such as functions
                stored in variables.
              </li>
            </ul>

            <p>
              <strong>Remember:</strong> Conditional invocation is a valuable
              tool for writing more resilient and reliable JavaScript code,
              especially when dealing with uncertain data structures or
              asynchronous operations.
            </p>
          </section>
          <section>
            <h2 id="objectCreationExpression"
              class="font-bold bg-gray-300 text-blue-700 shadow-lg p-2 hover:bg-blue-500 hover:text-white text- rounded-md text-center text-3xl hover:underline mb-8 mt-32">
              Object Creation Expression
            </h2>
            <p>
              <strong>In JavaScript, object creation expressions are ways to create
                new objects. There are two primary methods:</strong>
            </p>

            <h3>1. Object Literals:</h3>
            <ul>
              <li>
                <strong>Syntax:</strong>
                <code>const objectName = { property1: value1, property2: value2,
                    ... };</code>
              </li>
              <li>
                <strong>Directly define object properties and values within curly
                  braces.</strong>
              </li>
              <li>
                <strong>Simple and concise way to create objects.</strong>
              </li>
            </ul>

            <h3>Example:</h3>
            <pre><code>
                const person = {
                  name: "Alice",
                  age: 30,
                  hobbies: ["reading", "coding", "hiking"]
                };
              </code></pre>

            <h3>2. Constructor Functions:</h3>
            <ul>
              <li>
                <strong>Syntax:</strong>
                <code>const objectName = new
                    ConstructorFunction(arguments);</code>
              </li>
              <li>
                <strong>Use the <code>new</code> keyword to create an object
                  instance from a constructor function.</strong>
              </li>
              <li>
                <strong>Constructor functions typically define properties and
                  methods for the object.</strong>
              </li>
            </ul>

            <h3>Example:</h3>
            <pre><code>
                function Person(name, age) {
                  this.name = name;
                  this.age = age;
                  this.greet = function() {
                    console.log("Hello, my name is " + this.name);
                  };
                }
            
                const person1 = new Person("Bob", 25);
                person1.greet(); // Output: "Hello, my name is Bob"
              </code></pre>

            <h3>Key Points:</h3>
            <ul>
              <li>
                <strong>Object literals:</strong> More concise for simple
                objects with known properties.
              </li>
              <li>
                <strong>Constructor functions:</strong> Useful for creating
                multiple objects with similar structures and behaviors, and
                for defining methods.
              </li>
              <li>
                <strong>Both create objects with similar capabilities, but the
                  choice depends on the specific use case and complexity
                  requirements.</strong>
              </li>
            </ul>

            <h3>Additional Methods:</h3>
            <ul>
              <li>
                <strong><code>Object.create()</code>:</strong> Creates an
                object with a specified prototype.
              </li>
              <li>
                <strong>Class syntax:</strong> A more structured way to define
                constructor functions, introduced in ES6.
              </li>
            </ul>

            <p>
              <strong>Remember:</strong> Object creation expressions are
              fundamental for working with objects in JavaScript, as they
              allow you to model data and encapsulate functionality within
              your code.
            </p>
          </section>
        </div>
        <div class="operators" id="operator">
          <section>
            <h2 id="operators">In JavaScript, Operators</h2>
            <p>
              Operators are special symbols that perform operations on values
              (called operands) and produce results. They are essential for
              performing various tasks within code, from simple calculations
              to complex logical decisions.
            </p>

            <h3>Major Types of Operators in JavaScript:</h3>

            <ol>
              <li>
                <h4>Arithmetic Operators:</h4>
                <ul>
                  <li>
                    Perform basic mathematical operations like addition,
                    subtraction, multiplication, division, and modulus.
                  </li>
                  <li>
                    Examples: <code>+</code>, <code>-</code>, <code>*</code>,
                    <code>/</code>, <code>%</code>
                  </li>
                </ul>
              </li>

              <!-- ... Repeat this structure for other types of operators -->

              <!-- Example structure for another type of operator -->
              <li>
                <h4>Assignment Operators:</h4>
                <ul>
                  <li>
                    Assign values to variables. The most common is
                    <code>=</code>, but there are also compound assignment
                    operators that combine assignment with arithmetic
                    operations.
                  </li>
                  <li>
                    Examples: <code>=</code>, <code>+=</code>,
                    <code>-=</code>, <code>*=</code>, <code>/=</code>,
                    <code>%=</code>
                  </li>
                </ul>
              </li>
              <!-- ... Repeat this structure for other types of operators -->
            </ol>

            <p>
              Understanding operators is crucial for writing effective
              JavaScript code. Remember that operators have a specific order
              of precedence, which determines the sequence in which they are
              evaluated. Use parentheses to override the default precedence if
              needed.
            </p>
          </section>
          <section>
            <h2 id="arithmeticExpressions">
              Arithmetic Expressions in JavaScript
            </h2>
            <p>
              In JavaScript, an arithmetic expression is a combination of
              numbers, variables, and arithmetic operators that, when
              evaluated, results in a numerical value. It's like a
              mini-calculation that you write directly within your code.
            </p>

            <h3>Breakdown of Arithmetic Expressions:</h3>

            <ol>
              <li>
                <h4>Operands:</h4>
                <ul>
                  <li>
                    The numbers or variables that are being operated on.
                  </li>
                  <li>
                    Example: In <code>5 + 3</code>, the operands are 5 and 3.
                  </li>
                </ul>
              </li>

              <li>
                <h4>Operators:</h4>
                <ul>
                  <li>The symbols that perform the arithmetic operations.</li>
                  <li>
                    Common arithmetic operators in JavaScript:
                    <ul>
                      <li>Addition: <code>+</code></li>
                      <li>Subtraction: <code>-</code></li>
                      <li>Multiplication: <code>*</code></li>
                      <li>Division: <code>/</code></li>
                      <li>Modulus (remainder): <code>%</code></li>
                      <li>Exponentiation: <code>**</code></li>
                    </ul>
                  </li>
                </ul>
              </li>

              <li>
                <h4>Evaluation:</h4>
                <p>
                  The JavaScript engine processes the expression according to
                  the order of operations (PEMDAS/BODMAS) to produce a final
                  numerical result.
                </p>
              </li>

              <li>
                <h4>Result:</h4>
                <p>
                  The numerical value obtained after evaluating the
                  expression.
                </p>
              </li>
            </ol>

            <h3>Example of an Arithmetic Expression in JavaScript:</h3>

            <pre><code>
                let totalCost = 25 + 10 * 3 - 5;  // totalCost will be 40
              </code></pre>

            <h3>Visualizing an Arithmetic Expression:</h3>
            <!-- You can insert any visual representation here -->

            <h3>Key Points to Remember:</h3>
            <ul>
              <li>
                Use parentheses to control the order of evaluation if needed.
              </li>
              <li>
                Be mindful of data types: ensure you're working with numbers
                for arithmetic operations.
              </li>
              <li>
                Consider the context of variables and values when evaluating
                expressions.
              </li>
            </ul>
          </section>
          <section>
            <h2>Arithmetic Operators in JavaScript</h2>
            <p>
              Here's an explanation of arithmetic operators in JavaScript,
              along with examples:
            </p>

            <ol>
              <li>
                <h3>Addition (+):</h3>
                <ul>
                  <li>Adds two numbers together.</li>
                  <li>
                    Example: <code>let sum = 10 + 5; // sum will be 15</code>
                  </li>
                </ul>
              </li>

              <li>
                <h3>Subtraction (-):</h3>
                <ul>
                  <li>Subtracts the right number from the left number.</li>
                  <li>
                    Example:
                    <code>let difference = 15 - 8; // difference will be 7</code>
                  </li>
                </ul>
              </li>

              <li>
                <h3>Multiplication (*):</h3>
                <ul>
                  <li>Multiplies two numbers together.</li>
                  <li>
                    Example:
                    <code>let product = 4 * 6; // product will be 24</code>
                  </li>
                </ul>
              </li>

              <li>
                <h3>Division (/):</h3>
                <ul>
                  <li>Divides the left number by the right number.</li>
                  <li>Returns a floating-point number (decimal).</li>
                  <li>
                    Example:
                    <code>let quotient = 20 / 5; // quotient will be 4.0</code>
                  </li>
                </ul>
              </li>

              <li>
                <h3>Modulus (%):</h3>
                <ul>
                  <li>Returns the remainder of a division operation.</li>
                  <li>
                    Example:
                    <code>let remainder = 17 % 4; // remainder will be 1</code>
                  </li>
                </ul>
              </li>

              <li>
                <h3>Exponentiation (**):</h3>
                <ul>
                  <li>
                    Raises the left number (base) to the power of the right
                    number (exponent).
                  </li>
                  <li>Added in ECMAScript 2016.</li>
                  <li>
                    Example:
                    <code>let squared = 5 ** 2; // squared will be 25</code>
                  </li>
                </ul>
              </li>

              <li>
                <h3>Increment (++) and Decrement (--):</h3>
                <ul>
                  <li>Increase or decrease a number by 1, respectively.</li>
                  <li>Can be used in prefix or postfix form.</li>
                  <li>
                    Prefix: <code>++x</code> increments first, then uses the
                    value.
                  </li>
                  <li>
                    Postfix: <code>x++</code> uses the value first, then
                    increments.
                  </li>
                  <li>
                    Example:
                    <code>let num = 10; let result = ++num; // num becomes 11,
                        result is 11</code>
                  </li>
                </ul>
              </li>
            </ol>

            <p>
              <strong>Key points:</strong>
            </p>
            <ul>
              <li>
                <strong>Order of operations:</strong> Multiplication and
                division have higher precedence than addition and subtraction.
                Use parentheses to control the order of evaluation.
              </li>
              <li>
                <strong>Integer division:</strong> Dividing two integers
                results in an integer (whole number), discarding any decimal
                part.
              </li>
              <li>
                <strong>Floating-point division:</strong> To get a decimal
                result, ensure at least one operand is a floating-point number
                (e.g., <code>10.0 / 3</code> or <code>10 / 3.0</code>).
              </li>
              <li>
                <strong>Increment/decrement:</strong> The placement of the
                operator before or after the variable affects the value
                returned in expressions.
              </li>
            </ul>
          </section>
          <section>
            <h2 id="relationalExpressions ">
              Relational Expressions in JavaScript
            </h2>
            <p>
              Relational expressions in JavaScript compare two values and
              evaluate to a boolean result, either <code>true</code> or
              <code>false</code>. They are fundamental for making decisions
              and controlling the flow of code execution in JavaScript.
            </p>

            <h3>Common Relational Operators:</h3>

            <ul>
              <li>
                <strong>Equality operators:</strong>
                <ul>
                  <li>
                    <code>==</code> (equal to): Checks if two values are
                    equal.
                  </li>
                  <li>
                    <code>!=</code> (not equal to): Checks if two values are
                    not equal.
                  </li>
                </ul>
              </li>
              <li>
                <strong>Comparison operators:</strong>
                <ul>
                  <li>
                    <code>&gt;</code> (greater than): Checks if the left
                    operand is greater than the right operand.
                  </li>
                  <li>
                    <code>&lt;</code> (less than): Checks if the left operand
                    is less than the right operand.
                  </li>
                  <li>
                    <code>&gt;=</code> (greater than or equal to): Checks if
                    the left operand is greater than or equal to the right
                    operand.
                  </li>
                  <li>
                    <code>&lt;=</code> (less than or equal to): Checks if the
                    left operand is less than or equal to the right operand.
                  </li>
                </ul>
              </li>
            </ul>

            <h3>Additional Relational Operators:</h3>

            <ul>
              <li>
                <strong><code>in</code> operator:</strong> Checks if a
                property exists within an object.
              </li>
              <li>
                <strong><code>instanceof</code> operator:</strong> Checks if
                an object is an instance of a particular class or constructor.
              </li>
            </ul>

            <h3>Examples of Relational Expressions:</h3>

            <pre><code>
                let age = 25;
                let isAdult = age &gt;= 18;   // true
            
                let name = "John";
                let isJohn = name == "John";  // true
            
                let fruits = ["apple", "banana"];
                let hasBanana = "banana" in fruits;  // true
            
                let myObject = new Object();
                let isObject = myObject instanceof Object;  // true
              </code></pre>

            <h3>Key Applications of Relational Expressions:</h3>

            <ul>
              <li>
                <strong>Conditional statements:</strong> Used in
                <code>if</code>, <code>else if</code>, and
                <code>else</code> blocks to execute code based on certain
                conditions.
              </li>
              <li>
                <strong>Loops:</strong> Used in <code>while</code> and
                <code>for</code> loops to control the number of iterations.
              </li>
              <li>
                <strong>Decision-making:</strong> Used within functions and
                algorithms to make choices based on comparisons.
              </li>
              <li>
                <strong>Data validation:</strong> Used to check if values meet
                specific criteria.
              </li>
            </ul>
          </section>
          <section>
            <h2>Relational Operators in JavaScript</h2>
            <p>
              Relational operators in JavaScript compare two values and
              determine the relationship between them. They produce a boolean
              result, either <code>true</code> if the relationship holds or
              <code>false</code> if it doesn't.
            </p>

            <h3>Common Relational Operators:</h3>

            <ol>
              <li>
                <h4>Equal to (<code>==</code>):</h4>
                <ul>
                  <li>Checks if two values are equal.</li>
                  <li>
                    Example: <code>let isEqual = 10 == 10; // true</code>
                  </li>
                </ul>
              </li>

              <li>
                <h4>Not equal to (<code>!=</code>):</h4>
                <ul>
                  <li>Checks if two values are not equal.</li>
                  <li>
                    Example:
                    <code>let isNotEqual = 5 != "5"; // true (different
                        types)</code>
                  </li>
                </ul>
              </li>

              <!-- ... Repeat this structure for other relational operators -->

              <!-- Example for Greater than (>) -->
              <li>
                <h4>Greater than (<code>&gt;</code>):</h4>
                <ul>
                  <li>
                    Checks if the left value is greater than the right value.
                  </li>
                  <li>
                    Example: <code>let isGreater = 20 &gt; 15; // true</code>
                  </li>
                </ul>
              </li>
              <!-- ... Repeat this structure for other relational operators -->
            </ol>

            <h3>Key points to remember:</h3>

            <ul>
              <li>
                <strong>Value and Type Comparisons:</strong> JavaScript
                performs both value and type comparisons. Even if two values
                have the same numeric value, they might be considered
                different if their data types differ (e.g., <code>5</code> is
                not equal to <code>"5"</code>).
              </li>
              <li>
                <strong>Strict Equality:</strong> Use the
                <code>===</code> operator for strict equality, which also
                checks for type equality.
              </li>
              <li>
                <strong>Comparison with Non-Numbers:</strong> When comparing
                non-numeric values (like strings), JavaScript uses
                lexicographical (alphabetical) order for comparison.
              </li>
              <li>
                <strong>Common Use Cases:</strong>
                <ul>
                  <li>Conditional statements (if/else)</li>
                  <li>Loops (while, for)</li>
                  <li>Decision-making within code</li>
                </ul>
              </li>
            </ul>
          </section>
          <section>
            <h2 id="logicalExpressions">
              Logical Expressions and Operators in JavaScript
            </h2>
            <p>
              Logical expressions in JavaScript evaluate to a boolean value
              (true or false), playing a vital role in conditional logic and
              decision-making within your code.
            </p>

            <h3>Logical Expressions: The Questions Code Asks</h3>
            <ul>
              <li>
                In JavaScript, logical expressions are statements that
                evaluate to a boolean value (true or false).
              </li>
              <li>
                They're essential for crafting conditional logic within your
                code, guiding decision-making processes.
              </li>
              <li>
                Key actors in logical expressions are logical operators, which
                connect multiple conditions and create complex questions.
              </li>
            </ul>

            <h3>Logical Operators: The Gatekeepers of Truth</h3>
            <ol>
              <li>
                <h4>AND (<code>&amp;&amp;</code>): The Strict Gatekeeper</h4>
                <ul>
                  <li>
                    Requires <strong>all</strong> conditions to be true to
                    allow passage.
                  </li>
                  <li>
                    Example:
                    <code>isReady &amp;&amp; hasFuel &amp;&amp;
                        isClearedForTakeoff</code>
                  </li>
                </ul>
              </li>
              <li>
                <h4>OR (<code>||</code>): The Welcoming Host</h4>
                <ul>
                  <li>
                    Grants entry if <strong>at least one</strong> condition is
                    true.
                  </li>
                  <li>
                    Example:
                    <code>hasTicket || hasPass || knowsTheSecretKnock</code>
                  </li>
                </ul>
              </li>
              <li>
                <h4>NOT (<code>!</code>): The Reverser</h4>
                <ul>
                  <li>Flips the truth of a condition, like a switch.</li>
                  <li>Example: <code>!isBroken</code></li>
                </ul>
              </li>
            </ol>

            <h3>Short-Circuiting: JavaScript's Efficient Trick</h3>
            <ul>
              <li>
                JavaScript often optimizes evaluations using a technique
                called short-circuiting.
              </li>
              <li>
                If the first condition in an AND expression is false, the
                second condition isn't even checked (since the result would be
                false anyway).
              </li>
              <li>
                If the first condition in an OR expression is true, the second
                condition isn't checked (since the result is already true).
              </li>
              <li>This saves processing time and can prevent errors.</li>
            </ul>

            <h3>Truthy and Falsy Values: Beyond True and False</h3>
            <ul>
              <li>
                While boolean values (true and false) are the foundation of
                logical expressions, JavaScript also considers other values as
                "truthy" or "falsy."
              </li>
              <li>
                Truthy values (generally considered true):
                <ul>
                  <li>Non-zero numbers</li>
                  <li>Non-empty strings</li>
                  <li>Objects (even empty ones)</li>
                  <li>Arrays (even empty ones)</li>
                  <li>True itself</li>
                </ul>
              </li>
              <li>
                Falsy values (generally considered false):
                <ul>
                  <li>Zero</li>
                  <li>Empty strings ("")</li>
                  <li>Null</li>
                  <li>Undefined</li>
                  <li>NaN (Not a Number)</li>
                  <li>False itself</li>
                </ul>
              </li>
            </ul>

            <h3>Putting It All Together: Making Smart Decisions in Code</h3>
            <ul>
              <li>
                By mastering logical expressions and operators, you empower
                your code to make informed choices and execute actions based
                on specific conditions.
              </li>
              <li>
                This logic forms the backbone of conditional statements
                (if/else), loops (while, for), and many other programming
                constructs.
              </li>
              <li>
                Practice using these tools regularly to enhance your coding
                skills and create more intelligent, adaptable programs!
              </li>
            </ul>
          </section>
          <section>
            <h2>Assignment with Operation</h2>
            <p>
              In JavaScript, aside from the standard <code>=</code> assignment
              operator, there are various other assignment operators that
              offer shortcuts by combining assignment with other operations.
            </p>

            <p>
              For instance, the <code>+=</code> operator performs addition and
              assignment. For example:
            </p>

            <pre><code>total += salesTax; // Equivalent to: total = total + salesTax;</code></pre>

            <p>
              The <code>+=</code> operator works for both numbers and strings.
              For numbers, it performs addition and assignment, while for
              strings, it does concatenation and assignment.
            </p>

            <p>
              Similar operators include <code>-=</code>, <code>*=</code>,
              <code>&amp;=</code>, and others. Here is a table listing them:
            </p>

            <table>
              <caption>
                Assignment operators
              </caption>
              <thead>
                <tr>
                  <th>Operator</th>
                  <th>Example</th>
                  <th>Equivalent</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><code>+=</code></td>
                  <td><code>a += b</code></td>
                  <td><code>a = a + b</code></td>
                </tr>
                <!-- ... Other rows for different assignment operators -->
              </tbody>
            </table>

            <p>
              In most cases, the expression <code>a op= b</code>, where
              <code>op</code> is an operator, is equivalent to
              <code>a = a op b</code>.
            </p>

            <p>
              However, if <code>a</code> contains side effects like a function
              call or an increment operator, the two expressions might differ.
              For example:
            </p>

            <pre><code>data[i++] *= 2; // Not equivalent to: data[i++] = data[i++] * 2;</code></pre>
          </section>
          <section>
            <h2 id="assignmentExpression">Assignment Expressions</h2>

            <section>
              <h3>Assignment Expressions:</h3>
              <p>
                <strong>Purpose:</strong> Assign a value to a variable or
                property.
              </p>
              <p>
                <strong>Syntax:</strong>
                <code>variable_name = expression_to_evaluate</code>
              </p>
              <p><strong>Evaluation:</strong></p>
              <ul>
                <li>
                  The expression on the right-hand side is evaluated first.
                </li>
                <li>
                  The resulting value is then assigned to the variable on the
                  left-hand side.
                </li>
              </ul>
              <p>
                <strong>Value:</strong> The value of the entire assignment
                expression is the assigned value itself.
              </p>
              <h4>Example:</h4>
              <pre><code class="language-javascript">let age = 25;  // Assigns 25 to the variable 'age'
            let result = age * 2;  // Assigns the result of 50 to 'result'
            </code></pre>
            </section>

            <section>
              <h3>Assignment Operators:</h3>
              <p>
                <strong>Combine assignment with other operations.</strong>
              </p>
              <p><strong>Shorthand for common patterns.</strong></p>
              <p><strong>Common types:</strong></p>
              <table>
                <thead>
                  <tr>
                    <th>Operator</th>
                    <th>Meaning</th>
                    <th>Example</th>
                    <th>Equivalent to</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td>=</td>
                    <td>Simple assignment</td>
                    <td>x = y</td>
                    <td>x = y</td>
                  </tr>
                  <tr>
                    <td>+=</td>
                    <td>Addition assignment</td>
                    <td>x += y</td>
                    <td>x = x + y</td>
                  </tr>
                  <tr>
                    <td>-=</td>
                    <td>Subtraction assignment</td>
                    <td>x -= y</td>
                    <td>x = x - y</td>
                  </tr>
                  <tr>
                    <td>*=</td>
                    <td>Multiplication assignment</td>
                    <td>x *= y</td>
                    <td>x = x * y</td>
                  </tr>
                  <tr>
                    <td>/=</td>
                    <td>Division assignment</td>
                    <td>x /= y</td>
                    <td>x = x / y</td>
                  </tr>
                  <tr>
                    <td>%=</td>
                    <td>Remainder assignment</td>
                    <td>x %= y</td>
                    <td>x = x % y</td>
                  </tr>
                  <tr>
                    <td>**=</td>
                    <td>Exponentiation assignment</td>
                    <td>x **= y</td>
                    <td>x = x ** y</td>
                  </tr>
                  <tr>
                    <td>&lt;&lt;=</td>
                    <td>Left shift assignment</td>
                    <td>x &lt;&lt;= y</td>
                    <td>x = x &lt;&lt; y</td>
                  </tr>
                  <tr>
                    <td>&gt;&gt;=</td>
                    <td>Signed right shift assignment</td>
                    <td>x &gt;&gt;= y</td>
                    <td>x = x &gt;&gt; y</td>
                  </tr>
                  <tr>
                    <td>&gt;&gt;&gt;=</td>
                    <td>Unsigned right shift assignment</td>
                    <td>x &gt;&gt;&gt;= y</td>
                    <td>x = x &gt;&gt;&gt; y</td>
                  </tr>
                  <tr>
                    <td>&amp;=</td>
                    <td>Bitwise AND assignment</td>
                    <td>x &amp;= y</td>
                    <td>x = x &amp; y</td>
                  </tr>
                  <tr>
                    <td>^=</td>
                    <td>Bitwise XOR assignment</td>
                    <td>x ^= y</td>
                    <td>x = x ^ y</td>
                  </tr>
                  <tr>
                    <td>|=</td>
                    <td>Bitwise OR assignment</td>
                    <td>x |= y</td>
                    <td>x = x | y</td>
                  </tr>
                  <tr>
                    <td>&amp;&amp;=</td>
                    <td>Logical AND assignment</td>
                    <td>x &amp;&amp;= y</td>
                    <td>x = x &amp;&amp; y</td>
                  </tr>
                  <tr>
                    <td>||=</td>
                    <td>Logical OR assignment</td>
                    <td>x ||= y</td>
                    <td>x = x || y</td>
                  </tr>
                  <tr>
                    <td>??=</td>
                    <td>Nullish coalescing assignment</td>
                    <td>x ??= y</td>
                    <td>x = x ?? y</td>
                  </tr>
                </tbody>
              </table>

              <h4>Example:</h4>
              <pre><code class="language-javascript">let count = 0;
            count += 5;  // Equivalent to count = count + 5;
            let message = "Hello";
            message += " world!";  // Concatenates strings
            </code></pre>
            </section>
          </section>

          <section>
            <h2 id="evaluationExpressions">Evaluation Expressions</h2>

            <p>
              JavaScript can interpret strings of code using the global
              function <code>eval()</code> to produce a value:
            </p>
            <pre><code>eval("3+2") // =&gt; 5</code></pre>

            <p>
              However, using <code>eval()</code> for dynamic evaluation of
              code strings is rarely needed and can pose security risks. Avoid
              using it, especially with user-derived strings, to prevent
              vulnerabilities.
            </p>

            <p>
              <strong>Is <code>eval()</code> a function or an operator?</strong>
            </p>
            <p>
              <code>eval()</code> is a function, although it behaves akin to
              an operator, impacting code optimization due to its dynamic
              nature. Different restrictions have been imposed to mitigate
              optimization issues.
            </p>

            <h3><code>eval()</code> Function Details</h3>

            <p>
              <code>eval()</code> expects a string argument and attempts to
              parse and evaluate JavaScript code from it. If successful, it
              returns the value of the last expression or statement.
              Otherwise, it throws a <code>SyntaxError</code>.
            </p>

            <p>
              <code>eval()</code> uses the calling code's variable
              environment. It can access and modify variables defined in the
              calling context. Declarations with <code>let</code> or
              <code>const</code> create local variables within the evaluation.
            </p>

            <h3>Global <code>eval()</code></h3>

            <p>
              <code>eval()</code> can affect local optimizations. When invoked
              by any name other than "eval," it evaluates code as top-level
              global code, potentially defining new global variables or
              functions.
            </p>

            <h3>Strict <code>eval()</code></h3>

            <p>
              When used in strict mode or when evaluating code starting with
              <code>"use strict"</code>, <code>eval()</code> behaves with
              further restrictions. It allows querying and setting local
              variables but prevents defining new variables or functions
              within the local scope.
            </p>
          </section>
          <section>
            <h3 id="miscellaneousExpression">Miscellaneous Operators</h3>
            <p>
              JavaScript supports a number of other miscellaneous operators,
              described in the following sections.
            </p>

            <section>
              <h4 id="conditionalOperartor">The Conditional Operator (?:)</h4>
              <p>
                The conditional operator is the only ternary operator (three
                operands) in JavaScript and is sometimes actually called the
                ternary operator. This operator is sometimes written ?:,
                although it does not appear quite that way in code. Because
                this operator has three operands, the first goes before the ?,
                the second goes between the ? and the :, and the third goes
                after the :. It is used like this:
              </p>
              <pre><code>x > 0 ? x : -x // The absolute value of x</code></pre>
              <p>
                The operands of the conditional operator may be of any type.
                The first operand is evaluated and interpreted as a boolean.
                If the value of the first operand is truthy, then the second
                operand is evaluated, and its value is returned. Otherwise, if
                the first operand is falsy, then the third operand is
                evaluated, and its value is returned. Only one of the second
                and third operands is evaluated; never both.
              </p>
              <p>
                While you can achieve similar results using the if statement
                (§5.3.1), the ?: operator often provides a handy shortcut.
                Here is a typical usage, which checks to be sure that a
                variable is defined (and has a meaningful, truthy value) and
                uses it if so or provides a default value if not:
              </p>
              <pre><code>greeting = "hello " + (username ? username : "there");</code></pre>
              <p>
                This is equivalent to, but more compact than, the following if
                statement:
              </p>
              <pre><code>greeting = "hello ";
            if (username) {
              greeting += username;
            } else {
              greeting += "there";
            }</code></pre>
            </section>
          </section>
          <section>
            <h4 id="firstDefineOperator">First-Defined (??)</h4>
            <p>
              The first-defined operator <code>??</code> evaluates to its
              first defined operand: if its left operand is not null and not
              undefined, it returns that value. Otherwise, it returns the
              value of the right operand. Like the <code>&amp;&amp;</code> and
              <code>||</code> operators, <code>??</code> is short-circuiting:
              it only evaluates its second operand if the first operand
              evaluates to null or undefined. If the expression
              <code>a</code> has no side effects, then the expression
              <code>a ?? b</code> is equivalent to:
            </p>
            <pre><code>(a !== null &amp;&amp; a !== undefined) ? a : b</code></pre>
            <p>
              <code>??</code> is a useful alternative to <code>||</code> when
              you want to select the first defined operand rather than the
              first truthy operand. Although <code>||</code>
              is nominally a logical OR operator, it is also used
              idiomatically to select the first non-falsy operand with code
              like this:
            </p>
            <pre><code>// If maxWidth is truthy, use that. Otherwise, look for a
            // value in
            // the preferences object. If that is not truthy, use a
            hardcoded constant.
            let max = maxWidth || preferences.maxWidth || 500;
            </code></pre>
            <p>
              The problem with this idiomatic use is that zero, the empty
              string, and false are all falsy values that may be perfectly
              valid in some circumstances. In this code example, if
              <code>maxWidth</code> is zero, that value will be ignored. But
              if we change the <code>||</code> operator to <code>??</code>, we
              end up with an expression where zero is a valid value:
            </p>
            <pre><code>// If maxWidth is defined, use that. Otherwise, look for a
            // value in
            // the preferences object. If that is not defined, use a
            hardcoded constant.
            let max = maxWidth ?? preferences.maxWidth ?? 500;
            </code></pre>
            <!-- More content... -->
          </section>
          <section>
            <h4 id="typeofOperator">The typeof Operator</h4>
            <p>
              <code>typeof</code> is a unary operator that is placed before
              its single operand, which can be of any type. Its value is a
              string that specifies the type of the operand.
              <strong>Table 4-3</strong> specifies the value of the
              <code>typeof</code> operator for any JavaScript value.
            </p>
            <table>
              <caption>
                Values returned by the typeof operator
              </caption>
              <thead>
                <tr>
                  <th>x</th>
                  <th>typeof x</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>undefined</td>
                  <td>"undefined"</td>
                </tr>
                <tr>
                  <td>null</td>
                  <td>"object"</td>
                </tr>
                <tr>
                  <td>true or false</td>
                  <td>"boolean"</td>
                </tr>
                <!-- Fill in the rest of the table rows -->
                <tr>
                  <td>...</td>
                  <td>...</td>
                </tr>
              </tbody>
            </table>
            <p>
              You might use the <code>typeof</code> operator in an expression
              like this:
            </p>
            <pre><code>// If the value is a string, wrap it in quotes, otherwise, convert
            (typeof value === "string") ? "'" + value + "'" : value.toString()
            </code></pre>
            <p>
              Note that <code>typeof</code> returns “object” if the operand
              value is null. If you want to distinguish null from objects,
              you’ll have to explicitly test for this special-case value.
            </p>
            <p>
              Although JavaScript functions are a kind of object, the
              <code>typeof</code>
              operator considers functions to be sufficiently different that
              they have their own return value.
            </p>
            <p>
              Because <code>typeof</code> evaluates to “object” for all object
              and array values other than functions, it is useful only to
              distinguish objects from other, primitive types. In order to
              distinguish one class of object from another, you must use other
              techniques, such as the <code>instanceof</code>
              operator (see §4.9.4), the class attribute (see §14.4.3), or the
              constructor property (see §9.2.2 and §14.3).
            </p>
          </section>
          <section>
            <h4 id="deleteOperator">The delete Operator</h4>
            <p>
              <code>delete</code> is a unary operator that attempts to delete
              the object property or array element specified as its operand.
              Like the assignment, increment, and decrement operators,
              <code>delete</code> is typically used for its property deletion
              side effect and not for the value it returns. Some examples:
            </p>
            <pre><code>let o = { x: 1, y: 2}; // Start with an object
            delete o.x; // Delete one of its properties
            "x" in o // => false: the property does not
            exist anymore
            let a = [1,2,3]; // Start with an array
            delete a[2]; // Delete the last element of the
            array
            2 in a // => false: array element 2 doesn't
            exist anymore
            a.length // => 3: note that array length
            doesn't change, though
            </code></pre>
            <p>
              Note that a deleted property or array element is not merely set
              to the undefined value. When a property is deleted, the property
              ceases to exist. Attempting to read a nonexistent property
              returns undefined, but you can test for the actual existence of
              a property with the <code>in</code>
              operator (§4.9.3). Deleting an array element leaves a “hole” in
              the array and does not change the array’s length. The resulting
              array is sparse (§7.3).
            </p>
            <p>
              <code>delete</code> expects its operand to be an lvalue. If it
              is not an lvalue, the operator takes no action and returns true.
              Otherwise, <code>delete</code> attempts to delete the specified
              lvalue. <code>delete</code> returns true if it successfully
              deletes the specified lvalue. Not all properties can be deleted,
              however: non-configurable properties (§14.1) are immune from
              deletion.
            </p>
            <!-- More content -->
          </section>
          <section>
            <h4 id="awaitOperator">The await Operator</h4>
            <p>
              <code>await</code> was introduced in ES2017 as a way to make
              asynchronous programming more natural in JavaScript. You will
              need to read Chapter 13 to understand this operator. Briefly,
              however, <code>await</code> expects a Promise object
              (representing an asynchronous computation) as its sole operand,
              and it makes your program behave as if it were waiting for the
              asynchronous computation to complete (but it does this without
              actually blocking, and it does not prevent other asynchronous
              operations from proceeding at the same time). The value of the
              <code>await</code>
              operator is the fulfillment value of the Promise object.
              Importantly,
              <code>await</code> is only legal within functions that have been
              declared asynchronous with the <code>async</code> keyword.
              Again, see Chapter 13 for full details.
            </p>
          </section>
          <section>
            <h4 id="voidOperator">The void Operator</h4>
            <p>
              <code>void</code> is a unary operator that appears before its
              single operand, which may be of any type. This operator is
              unusual and infrequently used; it evaluates its operand, then
              discards the value and returns undefined. Since the operand
              value is discarded, using the <code>void</code> operator makes
              sense only if the operand has side effects.
            </p>
            <p>
              The <code>void</code> operator is so obscure that it is
              difficult to come up with a practical example of its use. One
              case would be when you want to define a function that returns
              nothing but also uses the arrow function shortcut syntax (see
              §8.1.3) where the body of the function is a single expression
              that is evaluated and returned. If you are evaluating the
              expression solely for its side effects and do not want to return
              its value, then the simplest thing is to use curly braces around
              the function body. But, as an alternative, you could also use
              the <code>void</code> operator in this case:
            </p>
            <pre><code>let counter = 0;
            const increment = () => void counter++;
            increment() // => undefined
            counter // => 1
            </code></pre>
          </section>
          <section>
            <h4 id="commaOperator">The Comma Operator (,)</h4>
            <p>
              The comma operator is a binary operator whose operands may be of
              any type. It evaluates its left operand, evaluates its right
              operand, and then returns the value of the right operand. Thus,
              the following line:
            </p>
            <pre><code>i=0, j=1, k=2;</code></pre>
            <p>Evaluates to <code>2</code> and is basically equivalent to:</p>
            <pre><code>i = 0; j = 1; k = 2;</code></pre>
            <p>
              The left-hand expression is always evaluated, but its value is
              discarded, which means that it only makes sense to use the comma
              operator when the left-hand expression has side effects. The
              only situation in which the comma operator is commonly used is
              with a for loop (§5.4.3) that has multiple loop variables:
            </p>
            <pre><code>// The first comma below is part of the syntax of the let
            statement
            // The second comma is the comma operator: it lets us squeeze
            2
            // expressions (i++ and j--) into a statement (the for loop)
            that expects 1.
            for(let i=0,j=10; i < j; i++,j--) {
              console.log(i+j);
            }
            </code></pre>
          </section>
        </div>
        <!-- -----------------------------statements------------------------------ -->
        <!-- -----------------------------statements------------------------------ -->
        <!-- -----------------------------statements------------------------------ -->
        <!-- -----------------------------statements------------------------------ -->
        <!-- -----------------------------statements------------------------------ -->
        <!-- -----------------------------statements------------------------------ -->
        <!-- -----------------------------statements------------------------------ -->
        <!-- -----------------------------statements------------------------------ -->
        <!-- -----------------------------statements------------------------------ -->
        <!-- -----------------------------statements------------------------------ -->
        <!-- -----------------------------statements------------------------------ -->
        <!-- -----------------------------statements------------------------------ -->
        <!-- -----------------------------statements------------------------------ -->
        <!-- -----------------------------statements------------------------------ -->
        <!-- -----------------------------statements------------------------------ -->
        <!-- -----------------------------statements------------------------------ -->
        <!-- -----------------------------statements------------------------------ -->
        <!-- -----------------------------statements------------------------------ -->
        <!-- -----------------------------statements------------------------------ -->
        <!-- -----------------------------statements------------------------------ -->
        <!-- -----------------------------statements------------------------------ -->
        <!-- -----------------------------statements------------------------------ -->
        <!-- -----------------------------statements------------------------------ -->
        <div class="statements">
          <section>
            <h2 id="statements">Understanding JavaScript Statements</h2>

            <article>
              <h3>Statements and Expressions</h3>
              <p>
                In JavaScript, statements function much like sentences in
                English, serving as commands that execute specific actions.
                Similar to how English sentences end with periods, JavaScript
                statements are concluded with semicolons (<a href="#section-2.6">§2.6</a>).
              </p>

              <p>
                Expressions, on the other hand, produce values when evaluated.
                However, statements are enacted to initiate actions.
              </p>
            </article>

            <article>
              <h3>Executing Actions</h3>
              <p>
                One method to initiate an action is by evaluating expressions
                with side effects. These expressions, involving assignments or
                function invocations, can exist independently as statements.
                When utilized in this manner, they are recognized as
                expression statements. Declaration statements are another set
                that introduces new variables and defines fresh functions.
              </p>
            </article>

            <article>
              <h3>Structure of JavaScript Programs</h3>
              <p>
                JavaScript programs essentially comprise sequences of
                statements for execution. By default, the JavaScript
                interpreter runs these statements sequentially, adhering to
                their written order. To alter this default sequence,
                JavaScript provides various statements or control structures:
              </p>

              <ol>
                <li>
                  <strong>Conditionals:</strong> Such as <code>if</code> and
                  <code>switch</code>, guide the interpreter to execute or
                  bypass statements based on expression values.
                </li>
                <li>
                  <strong>Loops:</strong> Like <code>while</code> and
                  <code>for</code>, repeatedly execute other statements.
                </li>
                <li>
                  <strong>Jumps:</strong> Examples include <code>break</code>,
                  <code>return</code>, and <code>throw</code>, causing the
                  interpreter to leap to different parts of the program.
                </li>
              </ol>

              <p>
                The subsequent sections detail these JavaScript statements,
                elucidating their syntax. Towards the chapter's conclusion,
                Table 5-1 summarizes the syntax. Remember, a JavaScript
                program is a sequence of statements separated by semicolons.
                Once you grasp these statements, you can embark on creating
                JavaScript programs.
              </p>
            </article>
          </section>
          <section>
            <h2 id="expressionStatements">Expression Statements</h2>

            <article>
              <p>
                The simplest kinds of statements in JavaScript are expressions
                that have side effects, as previously introduced in Chapter 4.
              </p>

              <p>
                Assignment statements stand as one major category of
                expression statements. For instance:
              </p>
              <code>greeting = "Hello " + name;<br />
                  i *= 3;</code>

              <p>
                The increment and decrement operators, <code>++</code> and
                <code>--</code>, are linked to assignment statements. They
                effectively alter a variable's value, similar to an
                assignment:
              </p>
              <code>counter++;</code>

              <p>
                The <code>delete</code> operator significantly deletes an
                object property. Hence, it's generally employed as a statement
                rather than as part of a broader expression:
              </p>
              <code>delete o.x;</code>

              <p>
                Function calls represent another substantial category of
                expression statements. For instance:
              </p>
              <code>console.log(debugMessage);<br />
                  displaySpinner(); // A hypothetical function to display a
                  spinner in a web app.</code>

              <p>
                While these function calls are expressions, they exert side
                effects on the host environment or program state, functioning
                here as statements. If a function lacks side effects, it's
                typically unnecessary to call it unless it's part of a larger
                expression or an assignment statement. For instance:
              </p>

              <p>
                You wouldn't merely compute a cosine and discard the result:
              </p>
              <code>Math.cos(x);</code>

              <p>
                However, you might compute the value and assign it to a
                variable for later use:
              </p>
              <code>cx = Math.cos(x);</code>

              <p>
                Note that each line of code in these examples is concluded
                with a semicolon.
              </p>
            </article>
          </section>
          <section>
            <h2 id="compoundEmptyStatements">
              Compound and Empty Statements
            </h2>

            <article>
              <p>
                Similar to how the comma operator (§4.13.7) merges multiple
                expressions into a single expression, a statement block
                amalgamates multiple statements into a compound statement. A
                statement block consists of a sequence of statements enclosed
                within curly braces, functioning as a unified statement
                wherever JavaScript anticipates one:
              </p>

              <pre><code>{
              x = Math.PI;
              cx = Math.cos(x);
              console.log("cos(π) = " + cx);
            }</code></pre>

              <p>
                Observations about this statement block: it doesn't conclude
                with a semicolon. Although the primitive statements within the
                block terminate with semicolons, the block itself doesn't.
                Additionally, the lines inside the block are typically
                indented concerning the enclosing curly braces. This isn't
                mandatory but enhances code readability and comprehension.
              </p>

              <p>
                Just as expressions often contain subexpressions, numerous
                JavaScript statements contain substatements. Typically,
                JavaScript syntax permits a single substatement. For instance,
                the syntax of a while loop incorporates a single statement
                acting as the loop's body. However, using a statement block
                allows inclusion of multiple statements within this single
                permissible substatement.
              </p>

              <p>
                A compound statement enables the use of multiple statements
                where JavaScript syntax expects a single statement.
                Conversely, the empty statement permits the inclusion of no
                statements where one is anticipated. The empty statement is
                represented as:
              </p>
              <pre><code>;</code></pre>

              <p>
                When the JavaScript interpreter executes an empty statement,
                it takes no action. Occasionally, the empty statement proves
                useful, particularly when creating a loop with an empty body.
                Consider this for loop example (covered in §5.4.3):
              </p>

              <pre><code>// Initialize an array a
            for(let i = 0; i < a.length; a[i++] = 0) ;</code></pre>

              <p>
                In this loop, the expression <code>a[i++] = 0</code> does all
                the work without requiring an actual loop body. JavaScript
                syntax necessitates a statement as a loop body, hence the
                usage of an empty statement—solely a semicolon.
              </p>

              <p>
                It's crucial to note that inadvertently adding a semicolon
                after the right parenthesis of a for loop, while loop, or if
                statement can lead to perplexing bugs that are challenging to
                identify. For example:
              </p>

              <pre><code>if ((a === 0) || (b === 0)); // Oops! This line does
            nothing...
            o = null; // and this line is always
            executed.</code></pre>

              <p>
                When intentionally employing the empty statement, it's
                advisable to comment the code to clarify the deliberate usage:
              </p>

              <pre><code>for(let i = 0; i < a.length; a[i++] = 0) /* empty */ ;</code></pre>
            </article>
          </section>
          <section>
            <h2 id="conditionals">Conditionals</h2>
            <p>
              Conditional statements execute or skip other statements
              depending on the value of a specified expression. These
              statements are the decision points of your code, and they are
              also sometimes known as “branches.” If you imagine a JavaScript
              interpreter following a path through your code, the conditional
              statements are the places where the code branches into two or
              more paths and the interpreter must choose which path to follow.
            </p>
            <p>
              The following subsections explain JavaScript’s basic
              conditional, the if/else statement, and also cover switch, a
              more complicated, multiway branch statement.
            </p>
            <div id="if">
              <h3>1. if</h3>
              <p>
                The if statement is the fundamental control statement that
                allows JavaScript to make decisions, or, more precisely, to
                execute statements conditionally. This statement has two
                forms.
                <br /><br />
                <strong>Form 1:</strong>
                <br />
                <code>if (expression) statement</code>
                <br />
                In this form, expression is evaluated. If the resulting value
                is truthy, statement is executed. If expression is falsy,
                statement is not executed.
                <br /><br />
                <em>Example:</em>
                <br />
                <code>if (username == null) // If username is null or undefined,
                    username = "John Doe"; // define it</code>
                <br /><br />
                Note that the parentheses around the expression are a required
                part of the syntax for the if statement.
                <br /><br />
                <strong>Form 2:</strong>
                <br />
                <code>if (expression) statement1 else statement2</code>
                <br />
                This form of the statement executes statement1 if expression
                is truthy and executes statement2 if expression is falsy.
                <br /><br />
                <em>Example:</em>
                <br />
                <code>if (n === 1) console.log("You have 1 new message."); else
                    console.log(`You have ${n} new messages.`);</code>
                <br /><br />
                When you have nested if statements with else clauses, some
                caution is required to ensure that the else clause goes with
                the appropriate if statement.
                <br /><br />
                Consider using curly braces to make your code clearer and less
                prone to errors.
              </p>
            </div>
            <div id="elseif">
              <h3>else if</h3>
              <p>
                The if/else statement evaluates an expression and executes one
                of two pieces of code, depending on the outcome. But what
                about when you need to execute one of many pieces of code? One
                way to do this is with an else if statement.
                <br /><br />
                <code>else if</code> is not really a JavaScript statement, but
                simply a frequently used programming idiom that results when
                repeated if/else statements are used: <br /><br />
                <code>
                    if (n === 1) { <br />
                    &nbsp;&nbsp;// Execute code block #1 <br />
                    } else if (n === 2) { <br />
                    &nbsp;&nbsp;// Execute code block #2 <br />
                    } else if (n === 3) { <br />
                    &nbsp;&nbsp;// Execute code block #3 <br />
                    } else { <br />
                    &nbsp;&nbsp;// If all else fails, execute block #4 <br />
                    }
                  </code>
                <br /><br />
                There is nothing special about this code. It is just a series
                of if statements, where each following if is part of the else
                clause of the previous statement. Using the
                <code>else if</code> idiom is preferable to, and more legible
                than, writing these statements out in their syntactically
                equivalent, fully nested form: <br /><br />
                <code>
                    if (n === 1) { <br />
                    &nbsp;&nbsp;// Execute code block #1 <br />
                    } <br />
                    else { <br />
                    &nbsp;&nbsp;if (n === 2) { <br />
                    &nbsp;&nbsp;&nbsp;&nbsp;// Execute code block #2 <br />
                    &nbsp;&nbsp;} <br />
                    &nbsp;&nbsp;else { <br />
                    &nbsp;&nbsp;&nbsp;&nbsp;if (n === 3) { <br />
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Execute code block #3
                    <br />
                    &nbsp;&nbsp;&nbsp;&nbsp;} <br />
                    &nbsp;&nbsp;&nbsp;&nbsp;else { <br />
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// If all else fails,
                    execute block #4 <br />
                    &nbsp;&nbsp;&nbsp;&nbsp;} <br />
                    &nbsp;&nbsp;} <br />
                    }
                  </code>
              </p>
            </div>
            <div id="switch">
              <h3>Switch Statement</h3>
              <p>
                An if statement causes a branch in the flow of a program’s
                execution, and you can use the else if idiom to perform a
                multiway branch. This is not the best solution, however, when
                all of the branches depend on the value of the same
                expression. In this case, it is wasteful to repeatedly
                evaluate that expression in multiple if statements.
                <br /><br />
                The switch statement handles exactly this situation. The
                <code>switch</code> keyword is followed by an expression in
                parentheses and a block of code in curly braces: <br /><br />
                <code>
                    switch(expression) { <br />
                    &nbsp;&nbsp;// statements <br />
                    }
                  </code>
                <br /><br />
                However, the full syntax of a switch statement is more complex
                than this. Various locations in the block of code are labeled
                with the <code>case</code> keyword followed by an expression
                and a colon. When a switch executes, it computes the value of
                expression and then looks for a case label whose expression
                evaluates to the same value (where sameness is determined by
                the <code>===</code> operator). If it finds one, it starts
                executing the block of code at the statement labeled by the
                case. If it does not find a case with a matching value, it
                looks for a statement labeled <code>default:</code>. If there
                is no <code>default:</code> label, the switch statement skips
                the block of code altogether. <br /><br />
                <code>
                    switch(n) { <br />
                    &nbsp;&nbsp;case 1: // Start here if n === 1 <br />
                    &nbsp;&nbsp;&nbsp;&nbsp;// Execute code block #1. <br />
                    &nbsp;&nbsp;&nbsp;&nbsp;break; // Stop here <br />
                    &nbsp;&nbsp;case 2: // Start here if n === 2 <br />
                    &nbsp;&nbsp;&nbsp;&nbsp;// Execute code block #2. <br />
                    &nbsp;&nbsp;&nbsp;&nbsp;break; // Stop here <br />
                    &nbsp;&nbsp;case 3: // Start here if n === 3 <br />
                    &nbsp;&nbsp;&nbsp;&nbsp;// Execute code block #3. <br />
                    &nbsp;&nbsp;&nbsp;&nbsp;break; // Stop here <br />
                    &nbsp;&nbsp;default: // If all else fails... <br />
                    &nbsp;&nbsp;&nbsp;&nbsp;// Execute code block #4. <br />
                    &nbsp;&nbsp;&nbsp;&nbsp;break; // Stop here <br />
                    }
                  </code>
                <br /><br />
                Note the <code>break</code> keyword used at the end of each
                case in this code. The <code>break</code> statement, described
                later in this chapter, causes the interpreter to jump to the
                end (or “break out”) of the switch statement and continue with
                the statement that follows it. The case clauses in a switch
                statement specify only the starting point of the desired code;
                they do not specify any ending point. In the absence of
                <code>break</code> statements, a switch statement begins
                executing its block of code at the case label that matches the
                value of its expression and continues executing statements
                until it reaches the end of the block. <br /><br />
                Here is a more realistic example of the switch statement; it
                converts a value to a string in a way that depends on the type
                of the value:
                <br /><br />
                <code>
                    function convert(x) { <br />
                    &nbsp;&nbsp;switch(typeof x) { <br />
                    &nbsp;&nbsp;&nbsp;&nbsp;case "number": // Convert the number
                    to a hexadecimal integer <br />
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return x.toString(16);
                    <br />
                    &nbsp;&nbsp;&nbsp;&nbsp;case "string": // Return the string
                    enclosed in quotes <br />
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return '"' + x + '"';
                    <br />
                    &nbsp;&nbsp;&nbsp;&nbsp;default: // Convert any other type
                    in the usual way <br />
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return String(x); <br />
                    &nbsp;&nbsp;} <br />
                    }
                  </code>
                <br /><br />
                The switch statement first evaluates the expression that
                follows the switch keyword and then evaluates the case
                expressions, in the order in which they appear, until it finds
                a value that matches. The matching case is determined using
                the <code>===</code> identity operator, not the
                <code>==</code> equality operator, so the expressions must
                match without any type conversion. <br /><br />
                Because not all of the case expressions are evaluated each
                time the switch statement is executed, you should avoid using
                case expressions that contain side effects such as function
                calls or assignments. The safest course is simply to limit
                your case expressions to constant expressions.
                <br /><br />
                As explained earlier, if none of the case expressions match
                the switch expression, the switch statement begins executing
                its body at the statement labeled <code>default:</code>. If
                there is no <code>default:</code> label, the switch statement
                skips its body altogether. Note that in the examples shown,
                the <code>default:</code> label appears at the end of the
                switch body, following all the case labels. This is a logical
                and common place for it, but it can actually appear anywhere
                within the body of the statement.
              </p>
            </div>
          </section>
          <section>
            <h3 id="loops">Loops</h3>
            <p>
              To understand conditional statements, we imagined the JavaScript
              interpreter following a branching path through your source code.
              The looping statements are those that bend that path back upon
              itself to repeat portions of your code. JavaScript has five
              looping statements: <code>while</code>, <code>do/while</code>,
              <code>for</code>, <code>for/of</code> (and its
              <code>for/await</code> variant), and <code>for/in</code>. The
              following subsections explain each in turn. One common use for
              loops is to iterate over the elements of an array. §7.6
              discusses this kind of loop in detail and covers special looping
              methods defined by the Array class.
            </p>
            <div>
              <h2 id="while"></h2>
              <p>
                Just as the if statement is JavaScript’s basic conditional,
                the while statement is JavaScript’s basic loop. It has the
                following syntax:
              </p>
              <pre><code>
              while (expression)
                statement
                </code></pre>
              <p>
                To execute a while statement, the interpreter first evaluates
                expression. If the value of the expression is falsy, then the
                interpreter skips over the statement that serves as the loop
                body and moves on to the next statement in the program. If, on
                the other hand, the expression is truthy, the interpreter
                executes the statement and repeats, jumping back to the top of
                the loop and evaluating expression again. Another way to say
                this is that the interpreter executes statement repeatedly
                while the expression is truthy. Note that you can create an
                infinite loop with the syntax while(true).
              </p>
              <p>
                Usually, you do not want JavaScript to perform exactly the
                same operation over and over again. In almost every loop, one
                or more variables change with each iteration of the loop.
                Since the variables change, the actions performed by executing
                statement may differ each time through the loop. Furthermore,
                if the changing variable or variables are involved in
                expression, the value of the expression may be different each
                time through the loop. This is important; otherwise, an
                expression that starts off truthy would never change, and the
                loop would never end! Here is an example of a while loop that
                prints the numbers from 0 to 9:
              </p>
              <pre><code>
              let count = 0;
              while(count < 10) {
                console.log(count);
                count++;
              }
                </code></pre>
              <p>
                As you can see, the variable count starts off at 0 and is
                incremented each time the body of the loop runs. Once the loop
                has executed 10 times, the expression becomes false (i.e., the
                variable count is no longer less than 10), the while statement
                finishes, and the interpreter can move on to the next
                statement in the program. Many loops have a counter variable
                like count. The variable names i, j, and k are commonly used
                as loop counters, though you should use more descriptive names
                if it makes your code easier to understand.
              </p>
            </div>
            <div id="dowhile">
              <h2>Do/While</h2>
              <p>
                The do/while loop is like a while loop, except that the loop
                expression is tested at the bottom of the loop rather than at
                the top. This means that the body of the loop is always
                executed at least once. The syntax is:
              </p>
              <pre><code>
              do
                statement
              while (expression);
                </code></pre>
              <p>
                The do/while loop is less commonly used than its while cousin—
                in practice, it is somewhat uncommon to be certain that you
                want a loop to execute at least once. Here’s an example of a
                do/while loop:
              </p>
              <pre><code>
              function printArray(a) {
                let len = a.length, i = 0;
                if (len === 0) {
                  console.log("Empty Array");
                } else {
                  do {
                    console.log(a[i]);
                  } while(++i < len);
                }
              }
                </code></pre>
              <p>
                There are a couple of syntactic differences between the
                do/while loop and the ordinary while loop. First, the do loop
                requires both the do keyword (to mark the beginning of the
                loop) and the while keyword (to mark the end and introduce the
                loop condition). Also, the do loop must always be terminated
                with a semicolon. The while loop doesn’t need a semicolon if
                the loop body is enclosed in curly braces.
              </p>
            </div>
            <div id="for">
              <p>
                The for statement provides a looping construct that is often
                more convenient than the while statement. The for statement
                simplifies loops that follow a common pattern. Most loops have
                a counter variable of some kind. This variable is initialized
                before the loop starts and is tested before each iteration of
                the loop. Finally, the counter variable is incremented or
                otherwise updated at the end of the loop body, just before the
                variable is tested again. In this kind of loop, the
                initialization, the test, and the update are the three crucial
                manipulations of a loop variable. The for statement encodes
                each of these three manipulations as an expression and makes
                those expressions an explicit part of the loop syntax:
              </p>
              <pre><code>
              for(initialize ; test ; increment)
                statement
                </code></pre>
              <p>
                initialize, test, and increment are three expressions
                (separated by semicolons) that are responsible for
                initializing, testing, and incrementing the loop variable.
                Putting them all in the first line of the loop makes it easy
                to understand what a for loop is doing and prevents mistakes
                such as forgetting to initialize or increment the loop
                variable.
              </p>
              <p>
                The simplest way to explain how a for loop works is to show
                the equivalent while loop:
              </p>
              <pre><code>
              initialize;
              while(test) {
                statement
                increment;
              }
                </code></pre>
              <p>
                In other words, the initialize expression is evaluated once,
                before the loop begins. To be useful, this expression must
                have side effects (usually an assignment). JavaScript also
                allows initialize to be a variable declaration statement so
                that you can declare and initialize a loop counter at the same
                time. The test expression is evaluated before each iteration
                and controls whether the body of the loop is executed. If test
                evaluates to a truthy value, the statement that is the body of
                the loop is executed. Finally, the increment expression is
                evaluated. Again, this must be an expression with side effects
                in order to be useful. Generally, it is either an assignment
                expression, or it uses the ++ or -- operators.
              </p>
              <p>
                We can print the numbers from 0 to 9 with a for loop like the
                following. Contrast it with the equivalent while loop shown in
                the previous section:
              </p>
              <pre><code>
              for(let count = 0; count < 10; count++) {
                console.log(count);
              }
                </code></pre>
              <p>
                Loops can become a lot more complex than this simple example,
                of course, and sometimes multiple variables change with each
                iteration of the loop. This situation is the only place that
                the comma operator is commonly used in JavaScript; it provides
                a way to combine multiple initialization and increment
                expressions into a single expression suitable for use in a for
                loop:
              </p>
              <pre><code>
              let i, j, sum = 0;
              for(i = 0, j = 10 ; i < 10 ; i++, j--) {
                sum += i * j;
              }
                </code></pre>
              <p>
                In all our loop examples so far, the loop variable has been
                numeric. This is quite common but is not necessary. The
                following code uses a for loop to traverse a linked list data
                structure and return the last object in the list (i.e., the
                first object that does not have a next property):
              </p>
              <pre><code>
              function tail(o) { // Return the
                tail of linked list o
                for(; o.next; o = o.next) /* empty */ ; // Traverse while
                o.next is truthy
                return o;
              }
                </code></pre>
              <p>
                Note that this code has no initialize expression. Any of the
                three expressions may be omitted from a for loop, but the two
                semicolons are required. If you omit the test expression, the
                loop repeats forever, and for(;;) is another way of writing an
                infinite loop, like while(true).
              </p>
            </div>
            <div id="forof">
              <p>
                ES6 defines a new loop statement: for/of. This new kind of
                loop uses the for keyword but is a completely different kind
                of loop than the regular for loop. (It is also completely
                different than the older for/in loop that we’ll describe in
                §5.4.5.)
              </p>
              <p>
                The for/of loop works with iterable objects. We’ll explain
                exactly what it means for an object to be iterable in Chapter
                12, but for this chapter, it is enough to know that arrays,
                strings, sets, and maps are iterable: they represent a
                sequence or set of elements that you can loop or iterate
                through using a for/of loop.
              </p>
              <p>
                Here, for example, is how we can use for/of to loop through
                the elements of an array of numbers and compute their sum:
              </p>
              <pre><code>
              let data = [1, 2, 3, 4, 5, 6, 7, 8, 9], sum = 0;
              for(let element of data) {
                sum += element;
              }
              sum // => 45
                </code></pre>
              <p>
                Superficially, the syntax looks like a regular for loop: the
                for keyword is followed by parentheses that contain details
                about what the loop should do. In this case, the parentheses
                contain a variable declaration (or, for variables that have
                already been declared, simply the name of the variable)
                followed by the of keyword and an expression that evaluates to
                an iterable object, like the data array in this case. As with
                all loops, the body of a for/of loop follows the parentheses,
                typically within curly braces.
              </p>
              <p>
                In the code just shown, the loop body runs once for each
                element of the data array. Before each execution of the loop
                body, the next element of the array is assigned to the element
                variable. Array elements are iterated in order from first to
                last.
              </p>
              <p>
                Arrays are iterated “live”—changes made during the iteration
                may affect the outcome of the iteration. If we modify the
                preceding code by adding the line data.push(sum); inside the
                loop body, then we create an infinite loop because the
                iteration can never reach the last element of the array.
              </p>
            </div>
            <div id="forofWithObjects">
              <p>
                Objects are not (by default) iterable. Attempting to use
                for/of on a regular object throws a TypeError at runtime:
              </p>
              <pre><code>
              let o = { x: 1, y: 2, z: 3 };
              for(let element of o) { // Throws TypeError because o is not iterable
                console.log(element);
              }
                </code></pre>
              <p>
                If you want to iterate through the properties of an object,
                you can use the for/in loop (introduced in §5.4.5), or use
                for/of with the Object.keys() method:
              </p>
              <pre><code>
              let o = { x: 1, y: 2, z: 3 };
              let keys = "";
              for(let k of Object.keys(o)) {
                keys += k;
              }
              keys // => "xyz"
                </code></pre>
              <p>
                This works because Object.keys() returns an array of property
                names for an object, and arrays are iterable with for/of. Note
                also that this iteration of the keys of an object is not live
                as the array example above was—changes to the object o made in
                the loop body will have no effect on the iteration. If you
                don’t care about the keys of an object, you can also iterate
                through their corresponding values like this:
              </p>
              <pre><code>
              let sum = 0;
              for(let v of Object.values(o)) {
                sum += v;
              }
              sum // => 6
                </code></pre>
              <p>
                And if you are interested in both the keys and the values of
                an object’s properties, you can use for/of with
                Object.entries() and destructuring assignment:
              </p>
              <pre><code>
              let pairs = "";
              for(let [k, v] of Object.entries(o)) {
                pairs += k + v;
              }
              pairs // => "x1y2z3"
                </code></pre>
              <p>
                Object.entries() returns an array of arrays, where each inner
                array represents a key/value pair for one property of the
                object. We use destructuring assignment in this code example
                to unpack those inner arrays into two individual variables.
              </p>
            </div>
            <div id="forofWithStrings">
              <p>Strings are iterable character-by-character in ES6:</p>
              <pre><code>
              let frequency = {};
              for(let letter of "mississippi") {
                if (frequency[letter]) {
                  frequency[letter]++;
                } else {
                  frequency[letter] = 1;
                }
              }
              frequency // => {m: 1, i: 4, s: 4, p: 2}
                </code></pre>
              <p>
                Note that strings are iterated by Unicode codepoint, not by
                UTF-16 character. The string “I ❤ ” has a .length of 5
                (because the two emoji characters each require two UTF-16
                characters to represent). But if you iterate that string with
                for/of, the loop body will run three times, once for each of
                the three code points “I”, “❤”, and “ ”.
              </p>
            </div>
            <div id="forofWithSetAndMaps">
              <p>
                The built-in ES6 Set and Map classes are iterable. When you
                iterate a Set with for/of, the loop body runs once for each
                element of the set. For example:
              </p>
              <pre><code>
              let text = "Na na na na na na na na Batman!";
              let wordSet = new Set(text.split(" "));
              let unique = [];
              for(let word of wordSet) {
                unique.push(word);
              }
              unique // => ["Na", "na", "Batman!"]
                </code></pre>
              <p>
                Maps are an interesting case because the iterator for a Map
                object does not iterate the Map keys or the Map values, but
                key/value pairs. Each time through the iteration, the iterator
                returns an array whose first element is a key and whose second
                element is the corresponding value. Given a Map m, you could
                iterate and destructure its key/value pairs like this:
              </p>
              <pre><code>
              let m = new Map([[1, "one"]]);
              for(let [key, value] of m) {
                key // => 1
                value // => "one"
              }
                </code></pre>
            </div>
            <div id="forawait">
              <h2>for/await loop</h2>
              <p>
                ES2018 introduces a new kind of iterator, known as an
                asynchronous iterator, and a variant on the for/of loop, known
                as the for/await loop that works with asynchronous iterators.
              </p>
              <p>
                You’ll need to read Chapters 12 and 13 in order to understand
                the for/await loop, but here is how it looks in code:
              </p>
              <pre><code>
              // Read chunks from an asynchronously iterable stream and print them out
              async function printStream(stream) {
                for await (let chunk of stream) {
                  console.log(chunk);
                }
              }
                </code></pre>
            </div>
            <div id="forin">
              <h2>for/in loop</h2>
              <p>
                A for/in loop looks a lot like a for/of loop, with the of
                keyword changed to in. While a for/of loop requires an
                iterable object after the of, a for/in loop works with any
                object after the in. The for/of loop is new in ES6, but for/in
                has been part of JavaScript since the very beginning (which is
                why it has the more natural sounding syntax).
              </p>
              <p>
                The for/in statement loops through the property names of a
                specified object. The syntax looks like this:
              </p>
              <pre><code>
                  for (variable in object)
                    statement
                </code></pre>
              <p>
                variable typically names a variable, but it may be a variable
                declaration or anything suitable as the left-hand side of an
                assignment expression. object is an expression that evaluates
                to an object. As usual, statement is the statement or
                statement block that serves as the body of the loop.
              </p>
              <p>And you might use a for/in loop like this:</p>
              <pre><code>
                  for(let p in o) { // Assign property names of o to variable p
                    console.log(o[p]); // Print the value of each property
                  }
                </code></pre>
              <!-- More content continues... -->
            </div>
          </section>
          <section>
            <h2 id="jumps">Jumps Statements</h2>
            <p>
              Another category of JavaScript statements are jump statements.
              As the name implies, these cause the JavaScript interpreter to
              jump to a new location in the source code. The
              <code>break</code> statement makes the interpreter jump to the
              end of a loop or other statement. <code>continue</code> makes
              the interpreter skip the rest of the body of a loop and jump
              back to the top of a loop to begin a new iteration. JavaScript
              allows statements to be named, or labeled, and
              <code>break</code> and <code>continue</code> can identify the
              target loop or other statement label.
            </p>
            <p>
              The <code>return</code> statement makes the interpreter jump
              from a function invocation back to the code that invoked it and
              also supplies the value for the invocation. The
              <code>throw</code> statement is a kind of interim return from a
              generator function. The <code>throw</code> statement raises, or
              throws, an exception and is designed to work with the
              <code>try</code>/<code>catch</code>/<code>finally</code>
              statement, which establishes a block of exception-handling code.
              This is a complicated kind of jump statement: when an exception
              is thrown, the interpreter jumps to the nearest enclosing
              exception handler, which may be in the same function or up the
              call stack in an invoking function.
            </p>
            <p>
              Details about each of these jump statements are in the sections
              that follow.
            </p>
            <div id="labels">
              <h2>JS Labels</h2>
              <p>
                Any statement may be labeled by preceding it with an
                identifier and a colon:
                <code>identifier: statement</code>
              </p>
              <p>
                By labeling a statement, you give it a name that you can use
                to refer to it elsewhere in your program. You can label any
                statement, although it is only useful to label statements that
                have bodies, such as loops and conditionals. By giving a loop
                a name, you can use <code>break</code> and
                <code>continue</code> statements inside the body of the loop
                to exit the loop or to jump directly to the top of the loop to
                begin the next iteration. <code>break</code> and
                <code>continue</code> are the only JavaScript statements that
                use statement labels; they are covered in the following
                subsections. Here is an example of a labeled
                <code>while</code> loop and a <code>continue</code> statement
                that uses the label.
              </p>
              <pre>
                  <code>
                    mainloop: while(token !== null) {
                      // Code omitted...
                      continue mainloop; // Jump to the next iteration of the named loop
                      // More code omitted...
                    }
                  </code>
                </pre>
              <p>
                The identifier you use to label a statement can be any legal
                JavaScript identifier that is not a reserved word. The
                namespace for labels is different than the namespace for
                variables and functions, so you can use the same identifier as
                a statement label and as a variable or function name.
                Statement labels are defined only within the statement to
                which they apply (and within its substatements, of course). A
                statement may not have the same label as a statement that
                contains it, but two statements may have the same label as
                long as neither one is nested within the other. Labeled
                statements may themselves be labeled. Effectively, this means
                that any statement may have multiple labels.
              </p>
            </div>
            <div id="breaks">
              <h2>BREAKS</h2>
              <p>
                The <code>break</code> statement, used alone, causes the
                innermost enclosing loop or switch statement to exit
                immediately. Its syntax is simple:
                <code>break;</code>
              </p>
              <p>
                Because it causes a loop or switch to exit, this form of the
                <code>break</code> statement is legal only if it appears
                inside one of these statements.
              </p>
              <p>
                You’ve already seen examples of the
                <code>break</code> statement within a switch statement. In
                loops, it is typically used to exit prematurely when, for
                whatever reason, there is no longer any need to complete the
                loop. When a loop has complex termination conditions, it is
                often easier to implement some of these conditions with
                <code>break</code> statements rather than trying to express
                them all in a single loop expression. The following code
                searches the elements of an array for a particular value. The
                loop terminates in the normal way when it reaches the end of
                the array; it terminates with a <code>break</code> statement
                if it finds what it is looking for in the array:
              </p>
              <pre>
                  <code>
                    for(let i = 0; i &lt; a.length; i++) {
                      if (a[i] === target) break;
                    }
                  </code>
                </pre>
              <p>
                JavaScript also allows the <code>break</code> keyword to be
                followed by a statement label (just the identifier, with no
                colon):
                <code>break labelname;</code>
              </p>
              <p>
                When <code>break</code> is used with a label, it jumps to the
                end of, or terminates, the enclosing statement that has the
                specified label. It is a syntax error to use
                <code>break</code> in this form if there is no enclosing
                statement with the specified label. With this form of the
                <code>break</code> statement, the named statement need not be
                a loop or switch: <code>break</code> can “break out of” any
                enclosing statement. This statement can even be a statement
                block grouped within curly braces for the sole purpose of
                naming the block with a label.
              </p>
              <p>
                A newline is not allowed between the
                <code>break</code> keyword and the <code>labelname</code>.
                This is a result of JavaScript’s automatic insertion of
                omitted semicolons: if you put a line terminator between the
                <code>break</code> keyword and the label that follows,
                JavaScript assumes you meant to use the simple, unlabeled form
                of the statement and treats the line terminator as a
                semicolon.
              </p>
              <p>
                You need the labeled form of the <code>break</code> statement
                when you want to break out of a statement that is not the
                nearest enclosing loop or a switch. The following code
                demonstrates:
              </p>
              <pre>
                  <code>
                    let matrix = getData(); // Get a 2D array of numbers from somewhere
                    // Now sum all the numbers in the matrix.
                    let sum = 0, success = false;
                    // Start with a labeled statement that we can break out of if errors occur
                    computeSum: if (matrix) {
                      for(let x = 0; x &lt; matrix.length; x++) {
                        let row = matrix[x];
                        if (!row) break computeSum;
                        for(let y = 0; y &lt; row.length; y++) {
                          let cell = row[y];
                          if (isNaN(cell)) break computeSum;
                          sum += cell;
                        }
                      }
                    }
                    // The break statements jump here. If we arrive here with success == false
                    // then there was something wrong with the matrix we were given.
                    // Otherwise, sum contains the sum of all cells of the matrix.
                  </code>
                </pre>
              <p>
                Finally, note that a <code>break</code> statement, with or
                without a label, cannot transfer control across function
                boundaries. You cannot label a function definition statement,
                for example, and then use that label inside the function.
              </p>
            </div>
            <div id="continues">
              <h2>continues</h2>
              <p>
                The <code>continue</code> statement is similar to the
                <code>break</code> statement. Instead of exiting a loop,
                however, <code>continue</code> restarts a loop at the next
                iteration. The <code>continue</code> statement’s syntax is
                just as simple as the <code>break</code> statement’s:
                <code>continue;</code>
              </p>
              <p>
                The <code>continue</code> statement can also be used with a
                label:
                <code>continue labelname;</code>
              </p>
              <p>
                The <code>continue</code> statement, in both its labeled and
                unlabeled forms, can be used only within the body of a loop.
                Using it anywhere else causes a syntax error.
              </p>
              <p>
                When the <code>continue</code> statement is executed, the
                current iteration of the enclosing loop is terminated, and the
                next iteration begins. This means different things for
                different types of loops:
              </p>
              <ul>
                <li>
                  In a <code>while</code> loop, the specified expression at
                  the beginning of the loop is tested again, and if it’s true,
                  the loop body is executed starting from the top.
                </li>
                <li>
                  In a <code>do/while</code> loop, execution skips to the
                  bottom of the loop, where the loop condition is tested again
                  before restarting the loop at the top.
                </li>
                <li>
                  In a <code>for</code> loop, the increment expression is
                  evaluated, and the test expression is tested again to
                  determine if another iteration should be done.
                </li>
                <li>
                  In a <code>for/of</code> or <code>for/in</code> loop, the
                  loop starts over with the next iterated value or next
                  property name being assigned to the specified variable.
                </li>
              </ul>
              <p>
                Note the difference in behavior of the
                <code>continue</code> statement in the <code>while</code> and
                <code>for</code> loops: a <code>while</code> loop returns
                directly to its condition, but a <code>for</code> loop first
                evaluates its increment expression and then returns to its
                condition. Earlier, we considered the behavior of the
                <code>for</code> loop in terms of an “equivalent”
                <code>while</code> loop. Because the
                <code>continue</code> statement behaves differently for these
                two loops, however, it is not actually possible to perfectly
                simulate a <code>for</code> loop with a
                <code>while</code> loop alone.
              </p>
              <p>
                The following example shows an unlabeled
                <code>continue</code> statement being used to skip the rest of
                the current iteration of a loop when an error occurs:
              </p>
              <pre>
                  <code>
                    for(let i = 0; i &lt; data.length; i++) {
                      if (!data[i]) continue; // Can't proceed with undefined data
                      total += data[i];
                    }
                  </code>
                </pre>
              <p>
                Like the <code>break</code> statement, the
                <code>continue</code> statement can be used in its labeled
                form within nested loops when the loop to be restarted is not
                the immediately enclosing loop. Also, as with the
                <code>break</code> statement, line breaks are not allowed
                between the <code>continue</code> statement and its
                <code>labelname</code>.
              </p>
            </div>
            <div id="returns">
              <h2>returns</h2>
              <p>
                Recall that function invocations are expressions and that all
                expressions have values. A <code>return</code> statement
                within a function specifies the value of invocations of that
                function. Here’s the syntax of the
                <code>return</code> statement:
                <code>return expression;</code>
              </p>
              <p>
                A <code>return</code> statement may appear only within the
                body of a function. It is a syntax error for it to appear
                anywhere else. When the <code>return</code> statement is
                executed, the function that contains it returns the value of
                <code>expression</code> to its caller. For example:
              </p>
              <pre>
                  <code>
                    function square(x) { return x*x; } // A function that has a return statement
                    square(2) // => 4
                  </code>
                </pre>
              <p>
                With no <code>return</code> statement, a function invocation
                simply executes each of the statements in the function body in
                turn until it reaches the end of the function and then returns
                to its caller. In this case, the invocation expression
                evaluates to <code>undefined</code>. The
                <code>return</code> statement often appears as the last
                statement in a function, but it need not be last: a function
                returns to its caller when a <code>return</code> statement is
                executed, even if there are other statements remaining in the
                function body.
              </p>
              <p>
                The <code>return</code> statement can also be used without an
                expression to make the function return
                <code>undefined</code> to its caller. For example:
              </p>
              <pre>
                  <code>
                    function displayObject(o) {
                      // Return immediately if the argument is null or undefined.
                      if (!o) return;
                      // Rest of function goes here...
                    }
                  </code>
                </pre>
              <p>
                Because of JavaScript’s automatic semicolon insertion (§2.6),
                you cannot include a line break between the
                <code>return</code> keyword and the expression that follows
                it.
              </p>
            </div>
            <div id="yields">
              <h2>yields</h2>
              <p>
                The <code>yield</code> statement is much like the
                <code>return</code> statement but is used only in ES6
                generator functions (see §12.3) to produce the next value in
                the generated sequence of values without actually returning:
              </p>
              <pre>
                  <code>
                    // A generator function that yields a range of integers
                    function* range(from, to) {
                      for(let i = from; i &lt;= to; i++) {
                        yield i;
                      }
                    }
                  </code>
                </pre>
              <p>
                In order to understand <code>yield</code>, you must understand
                iterators and generators, which will not be covered until
                Chapter 12. <code>yield</code> is included here for
                completeness, however. (Technically, though,
                <code>yield</code> is an operator rather than a statement, as
                explained in §12.4.2.)
              </p>
            </div>
            <div id="throws">
              <h2>throws</h2>
              <p>
                An exception is a signal that indicates that some sort of
                exceptional condition or error has occurred. To throw an
                exception is to signal such an error or exceptional condition.
                To catch an exception is to handle it — to take whatever
                actions are necessary or appropriate to recover from the
                exception. In JavaScript, exceptions are thrown whenever a
                runtime error occurs and whenever the program explicitly
                throws one using the <code>throw</code> statement. Exceptions
                are caught with the <code>try/catch/finally</code> statement,
                which is described in the next section.
              </p>
              <p>
                The <code>throw</code> statement has the following syntax:
              </p>
              <pre>
                  <code>
                    throw expression;
                  </code>
                </pre>
              <p>
                <code>expression</code> may evaluate to a value of any type.
                You might throw a number that represents an error code or a
                string that contains a human-readable error message. The
                <code>Error</code> class and its subclasses are used when the
                JavaScript interpreter itself throws an error, and you can use
                them as well. An <code>Error</code> object has a
                <code>name</code> property that specifies the type of error
                and a <code>message</code> property that holds the string
                passed to the constructor function. Here is an example
                function that throws an <code>Error</code> object when invoked
                with an invalid argument:
              </p>
              <pre>
                  <code>
                    function factorial(x) {
                      // If the input argument is invalid, throw an exception!
                      if (x &lt; 0) throw new Error("x must not be negative");
                      // Otherwise, compute a value and return normally
                      let f;
                      for(f = 1; x &gt; 1; f *= x, x--) /* empty */ ;
                      return f;
                    }
                    factorial(4) // => 24
                  </code>
                </pre>
              <p>
                When an exception is thrown, the JavaScript interpreter
                immediately stops normal program execution and jumps to the
                nearest exception handler. Exception handlers are written
                using the <code>catch</code> clause of the
                <code>try/catch/finally</code> statement, which is described
                in the next section. If the block of code in which the
                exception was thrown does not have an associated
                <code>catch</code> clause, the interpreter checks the
                next-highest enclosing block of code to see if it has an
                exception handler associated with it. This continues until a
                handler is found. If an exception is thrown in a function that
                does not contain a <code>try/catch/finally</code> statement to
                handle it, the exception propagates up to the code that
                invoked the function. In this way, exceptions propagate up
                through the lexical structure of JavaScript methods and up the
                call stack. If no exception handler is ever found, the
                exception is treated as an error and is reported to the user.
              </p>
            </div>
            <div id="trycatchfinally">
              <h2>trycatchfinally</h2>
              <p>
                The try/catch/finally statement is JavaScript’s exception
                handling mechanism. The try clause of this statement simply
                defines the block of code whose exceptions are to be handled.
                The try block is followed by a catch clause, which is a block
                of statements that are invoked when an exception occurs
                anywhere within the try block. The catch clause is followed by
                a finally block containing cleanup code that is guaranteed to
                be executed, regardless of what happens in the try block. Both
                the catch and finally blocks are optional, but a try block
                must be accompanied by at least one of these blocks. The try,
                catch, and finally blocks all begin and end with curly braces.
                These braces are a required part of the syntax and cannot be
                omitted, even if a clause contains only a single statement.
              </p>
              <!-- More content -->
              <p>
                Note that the catch keyword is generally followed by an
                identifier in parentheses. This identifier is like a function
                parameter. When an exception is caught, the value associated
                with the exception (an Error object, for example) is assigned
                to this parameter. The identifier associated with a catch
                clause has block scope—it is only defined within the catch
                block.
              </p>
              <!-- More content -->
              <p>
                Here is a realistic example of the try/catch statement. It
                uses the factorial() method defined in the previous section
                and the client-side JavaScript methods prompt() and alert()
                for input and output:
              </p>
              <pre>
                  <code>
                    try {
                      // Ask the user to enter a number
                      let n = Number(prompt("Please enter a positive integer", ""));
                      // Compute the factorial of the number, assuming the input is valid
                      let f = factorial(n);
                      // Display the result
                      alert(n + "! = " + f);
                    }
                    catch(ex) { // If the user's input was not valid, we end up here
                      alert(ex); // Tell the user what the error is
                    }
                  </code>
                </pre>
              <!-- More content -->
              <p>
                This example is a try/catch statement with no finally clause.
                Although finally is not used as often as catch, it can be
                useful. However, its behavior requires additional explanation.
                The finally clause is guaranteed to be executed if any portion
                of the try block is executed, regardless of how the code in
                the try block completes. It is generally used to clean up
                after the code in the try clause.
              </p>
              <!-- More content -->
              <p>
                In the normal case, the JavaScript interpreter reaches the end
                of the try block and then proceeds to the finally block, which
                performs any necessary cleanup. If the interpreter left the
                try block because of a return, continue, or break statement,
                the finally block is executed before the interpreter jumps to
                its new destination.
              </p>
              <!-- More content -->
              <p>
                If an exception occurs in the try block and there is an
                associated catch block to handle the exception, the
                interpreter first executes the catch block and then the
                finally block. If there is no local catch block to handle the
                exception, the interpreter first executes the finally block
                and then jumps to the nearest containing catch clause.
              </p>
              <!-- More content -->
              <p>
                If a finally block itself causes a jump with a return,
                continue, break, or throw statement, or by calling a method
                that throws an exception, the interpreter abandons whatever
                jump was pending and performs the new jump. For example, if a
                finally clause throws an exception, that exception replaces
                any exception that was in the process of being thrown. If a
                finally clause issues a return statement, the method returns
                normally, even if an exception has been thrown and has not yet
                been handled.
              </p>
              <!-- More content -->
              <p>
                try and finally can be used together without a catch clause.
                In this case, the finally block is simply cleanup code that is
                guaranteed to be executed, regardless of what happens in the
                try block. Recall that we can’t completely simulate a for loop
                with a while loop because the continue statement behaves
                differently for the two loops. If we add a try/finally
                statement, we can write a while loop that works like a for
                loop and that handles continue statements correctly:
              </p>
              <pre>
                  <code>
                    // Simulate for(initialize ; test ;increment ) body;
                    initialize ;
                    while( test ) {
                      try { body ; }
                      finally { increment ; }
                    }
                  </code>
                </pre>
              <!-- More content -->
              <p>
                Note, however, that a body that contains a break statement
                behaves slightly differently (causing an extra increment
                before exiting) in the while loop than it does in the for
                loop, so even with the finally clause, it is not possible to
                completely simulate the for loop with while.
              </p>
            </div>
          </section>
          <section>
            <div>
              <h2 id="miscellaneousStatements">Miscellaneous Statements</h2>
              <div id="with">
                <h3>5.6.1 with</h3>
                <p>
                  The with statement runs a block of code as if the properties
                  of a specified object were variables in scope for that code.
                  It has the following syntax:
                </p>
                <!-- Content goes here -->
              </div>
              <!-- More content -->
              <div id="debugger">
                <h3>5.6.2 debugger</h3>
                <p>
                  The debugger statement normally does nothing. If, however, a
                  debugger program is available and is running, then an
                  implementation may (but is not required to) perform some
                  kind of debugging action. In practice, this statement acts
                  like a breakpoint: execution of JavaScript code stops, and
                  you can use the debugger to print variables’ values, examine
                  the call stack, and so on.
                </p>
                <!-- Content goes here -->
              </div>
              <!-- More content -->
              <div id="useStrict">
                <h3>5.6.3 “use strict”</h3>
                <p>
                  "use strict" is a directive introduced in ES5. Directives
                  are not statements (but are close enough that "use strict"
                  is documented here). There are two important differences
                  between the "use strict" directive and regular statements:
                </p>
                <!-- Content goes here -->
              </div>
              <!-- More content -->
            </div>
          </section>
          <section>
            <h2 id="declarations">Declarations</h2>
            <p>
              The keywords const, let, var, function, class, import, and
              export are not technically statements, but they look a lot like
              statements, and this book refers informally to them as
              statements, so they deserve a mention in this chapter.
            </p>
            <p>
              These keywords are more accurately described as declarations
              rather than statements. We said at the start of this chapter
              that statements “make something happen.” Declarations serve to
              define new values and give them names that we can use to refer
              to those values. They don’t make much happen themselves, but by
              providing names for values they, in an important sense, define
              the meaning of the other statements in your program.
            </p>
            <p>
              When a program runs, it is the program’s expressions that are
              being evaluated and the program’s statements that are being
              executed. The declarations in a program don’t “run” in the same
              way: instead, they define the structure of the program itself.
              Loosely, you can think of declarations as the parts of the
              program that are processed before the code starts running.
            </p>
            <p>
              JavaScript declarations are used to define constants, variables,
              functions, and classes and for importing and exporting values
              between modules. The next subsections give examples of all of
              these declarations. They are all covered in much more detail
              elsewhere in this book.
            </p>
            <div>
              <h2>const</h2>
              <p>
                The const, let, and var declarations are covered in §3.10. In
                ES6 and later, const declares constants, and let declares
                variables. Prior to ES6, the var keyword was the only way to
                declare variables and there was no way to declare constants.
                Variables declared with var are scoped to the containing
                function rather than the containing block. This can be a
                source of bugs, and in modern JavaScript there is really no
                reason to use var instead of let.
              </p>
              <pre><code>
              const TAU = 2 * Math.PI;
              let radius = 3;
              var circumference = TAU * radius;
                </code></pre>
            </div>

            <div>
              <h2>let</h2>
              <p>(Content about the 'let' declaration goes here)</p>
            </div>

            <div>
              <h2>var</h2>
              <p>(Content about the 'var' declaration goes here)</p>
            </div>

            <div>
              <h2>function</h2>
              <p>(Content about the 'function' declaration goes here)</p>
            </div>

            <div>
              <h2>class</h2>
              <p>(Content about the 'class' declaration goes here)</p>
            </div>

            <div>
              <h2>import and export</h2>
              <p>
                (Content about the 'import' and 'export' declarations goes
                here)
              </p>
            </div>
          </section>
        </div>

        <!-- Lexical Structure sub-heading Bookmark div end -->
      </div>
      <!-- Lexical Structure sub-heading Bookmark div end -->
      <!--************* main content div end*************************************** -->
    </div>
    <!--************* main content div end*************************************** -->

    <!-- Container for all the elements -->
  </div>
  <!-- Container for all the elements end div -->
  <!-- Scroll to top button -->
  <button class="scroll-to-top-btn">↑</button>
  <script src="./js_tutorial.js"></script>
</body>

</html>